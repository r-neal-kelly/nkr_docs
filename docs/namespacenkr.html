<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: nkr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">My C++20 library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">nkr Namespace Reference<div class="ingroups"><a class="el" href="group____d1cd4369__e0f4__4062__8f58__611395da215e.html">namespaces</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacenkr_1_1_0batomic__t"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr_1_1_0batomic__t.html">$atomic_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenkr_1_1_0bmaybe__t"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr_1_1_0bmaybe__t.html">$maybe_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenkr_1_1_0bpointer__t"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr_1_1_0bpointer__t.html">$pointer_t</a></td></tr>
<tr class="memdesc:namespacenkr_1_1_0bpointer__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains specializations for <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenkr_1_1allocator"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr_1_1allocator.html">allocator</a></td></tr>
<tr class="memdesc:namespacenkr_1_1allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains allocators that satisfy <a class="el" href="conceptnkr_1_1allocator__i.html" title="Defines common functionality that must exist on an allocator implementation for use in nkr.">nkr::allocator_i</a>, making them interchangably useful anywhere that accepts the allocator interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenkr_1_1os"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr_1_1os.html">os</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t.html">atomic_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t_3_01boolean__p_01_4.html">atomic_t&lt; boolean_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t_3_01c__pointer__p_01_4.html">atomic_t&lt; c_pointer_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t_3_01integer__p_01_4.html">atomic_t&lt; integer_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t_3_01real__p_01_4.html">atomic_t&lt; real_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1atomic__t_3_01void__t_01_5_01_4.html">atomic_t&lt; void_t * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1maybe__t_3_01built__in__p_01_4.html">maybe_t&lt; built_in_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1maybe__t_3_01user__defined__p_01_4.html">maybe_t&lt; user_defined_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1none__t.html">none_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1pointer__t.html">pointer_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1pointer__t_3_01any__non__type__p_01_4.html">pointer_t&lt; any_non_type_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1pointer__t_3_01any__type__p_01_4.html">pointer_t&lt; any_type_p &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1some__t.html">some_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1tr.html">tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to filter a type by its qualifications, and by other types, templates, identities, and generics in the context of a declaration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1allocator__i.html">allocator_i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines common functionality that must exist on an allocator implementation for use in nkr. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1maybe__i.html">maybe_i</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1none__i.html">none_i</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1some__i.html">some_i</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1any__type__tr.html">any_type_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actual type. Pretty much anything but <a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9" title="Same as void with a _t suffix.">nkr::void_t</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1to__boolean__tr.html">to_boolean_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Includes both <a class="el" href="group__intrinsics__primitives.html#gad05619436af7cbd3f917c34f6ca5bb0a" title="Relegated to the std namespace in favor of nkr::bool_t.">nkr::c_bool_t</a> and <a class="el" href="classnkr_1_1bool__t.html">nkr::bool_t</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__tr.html">integer_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either unsigned or signed integers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__unsigned__tr.html">integer_unsigned_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__signed__tr.html">integer_signed_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__word__tr.html">integer_word_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only allows integers that are the same size as <a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b" title="The largest natural type available, the processor&#39;s word.">nkr::word_t</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__8__tr.html">integer_8_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__16__tr.html">integer_16_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__32__tr.html">integer_32_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1integer__64__tr.html">integer_64_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1to__integer__tr.html">to_integer_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1real__tr.html">real_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1real__32__tr.html">real_32_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1real__64__tr.html">real_64_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1to__real__tr.html">to_real_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1c__pointer__tr.html">c_pointer_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In addition to regular pointers, this also includes nullptr. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1type__pointer__tr.html">type_pointer_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only pointers that point to a any_type_tr type, which includes std::nullptr_t. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1built__in__tr.html">built_in_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Includes <a class="el" href="group__intrinsics__primitives.html#gad05619436af7cbd3f917c34f6ca5bb0a" title="Relegated to the std namespace in favor of nkr::bool_t.">nkr::c_bool_t</a>, <a class="el" href="conceptnkr_1_1integer__tr.html" title="Either unsigned or signed integers.">nkr::integer_tr</a>, <a class="el" href="conceptnkr_1_1real__tr.html">nkr::real_tr</a>, and <a class="el" href="conceptnkr_1_1c__pointer__tr.html" title="In addition to regular pointers, this also includes nullptr.">nkr::c_pointer_tr</a>. The opposite of <a class="el" href="conceptnkr_1_1user__defined__tr.html" title="Includes non-built-in types, the opposite of nkr::built_in_tr.">nkr::user_defined_tr</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1user__defined__tr.html">user_defined_tr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Includes non-built-in types, the opposite of <a class="el" href="conceptnkr_1_1built__in__tr.html" title="Includes nkr::c_bool_t, nkr::integer_tr, nkr::real_tr, and nkr::c_pointer_tr. The opposite of nkr::us...">nkr::built_in_tr</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1same__or__base__of__tr.html">same_or_base_of_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptnkr_1_1same__or__derived__from__tr.html">same_or_derived_from_tr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac2fadabeca6af1088b2114f4b32cc63f"><td class="memTemplParams" colspan="2">template&lt;typename type_p &gt; </td></tr>
<tr class="memitem:ac2fadabeca6af1088b2114f4b32cc63f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t</a> = nkr::$tr::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt;</td></tr>
<tr class="memdesc:ac2fadabeca6af1088b2114f4b32cc63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A way to wrap a single type for use with an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression, to differentiate it from a template.  <a href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">More...</a><br /></td></tr>
<tr class="separator:ac2fadabeca6af1088b2114f4b32cc63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4babe1476e170123b9682b67160a0e8"><td class="memTemplParams" colspan="2">template&lt;nkr::generic_ ::tag::logic_gate_tr operator_p, typename ... types_p&gt; </td></tr>
<tr class="memitem:ae4babe1476e170123b9682b67160a0e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts</a> = nkr::$tr::ts&lt; operator_p, nkr::tuple::types_t&lt; types_p... &gt; &gt;</td></tr>
<tr class="memdesc:ae4babe1476e170123b9682b67160a0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A way to parenthesize and perform logical operations on several types in an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression.  <a href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">More...</a><br /></td></tr>
<tr class="separator:ae4babe1476e170123b9682b67160a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ca1dc69cb9a052d8bc183cf5e69dcb"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ... &gt; typename template_p&gt; </td></tr>
<tr class="memitem:ad9ca1dc69cb9a052d8bc183cf5e69dcb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt</a> = nkr::$tr::tts&lt; AND_tg, nkr::tuple::templates_t&lt; template_p &gt; &gt;</td></tr>
<tr class="memdesc:ad9ca1dc69cb9a052d8bc183cf5e69dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A way to wrap a single template for use with an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression, to differentiate it from a type.  <a href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">More...</a><br /></td></tr>
<tr class="separator:ad9ca1dc69cb9a052d8bc183cf5e69dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41183e8bf88f05fd2c80a26fa6ebb52"><td class="memTemplParams" colspan="2">template&lt;nkr::generic_ ::tag::logic_gate_tr operator_p, template&lt; typename ... &gt; typename ... templates_p&gt; </td></tr>
<tr class="memitem:aa41183e8bf88f05fd2c80a26fa6ebb52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">tts</a> = nkr::$tr::tts&lt; operator_p, nkr::tuple::templates_t&lt; templates_p... &gt; &gt;</td></tr>
<tr class="memdesc:aa41183e8bf88f05fd2c80a26fa6ebb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A way to parenthesize and perform logical operations on several templates in an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression.  <a href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">More...</a><br /></td></tr>
<tr class="separator:aa41183e8bf88f05fd2c80a26fa6ebb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1898ff80c7081762a1840f00883fa258"><td class="memTemplParams" colspan="2">template&lt;nkr::ts_tr subjects_p, typename ... expression_parts_p&gt; </td></tr>
<tr class="memitem:a1898ff80c7081762a1840f00883fa258"><td class="memTemplItemLeft" align="right" valign="top">constexpr nkr::boolean::cpp_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a> () noexcept</td></tr>
<tr class="memdesc:a1898ff80c7081762a1840f00883fa258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to filter a type by its qualifications, and by other types, templates, identities, and generics.  <a href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">More...</a><br /></td></tr>
<tr class="separator:a1898ff80c7081762a1840f00883fa258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2b0a5823f1763322168ce5405ba455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr.html#a7e2b0a5823f1763322168ce5405ba455">operator==</a> (built_in_tr auto built_in, is_any_tr&lt; <a class="el" href="classnkr_1_1none__t.html">none_t</a> &gt; auto none)</td></tr>
<tr class="separator:a7e2b0a5823f1763322168ce5405ba455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d72db753f1c18cb2ec4b3d4fbddfcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenkr.html#a47d72db753f1c18cb2ec4b3d4fbddfcb">operator!=</a> (built_in_tr auto built_in, is_any_tr&lt; <a class="el" href="classnkr_1_1none__t.html">none_t</a> &gt; auto none)</td></tr>
<tr class="separator:a47d72db753f1c18cb2ec4b3d4fbddfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034482d2e50c6d0448a7953d24860fe9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> = void</td></tr>
<tr class="memdesc:ga034482d2e50c6d0448a7953d24860fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>void</code> with a _t suffix.  <a href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">More...</a><br /></td></tr>
<tr class="separator:ga034482d2e50c6d0448a7953d24860fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05619436af7cbd3f917c34f6ca5bb0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__primitives.html#gad05619436af7cbd3f917c34f6ca5bb0a">c_bool_t</a> = bool</td></tr>
<tr class="memdesc:gad05619436af7cbd3f917c34f6ca5bb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relegated to the std namespace in favor of <a class="el" href="classnkr_1_1bool__t.html">nkr::bool_t</a>.  <a href="group__intrinsics__primitives.html#gad05619436af7cbd3f917c34f6ca5bb0a">More...</a><br /></td></tr>
<tr class="separator:gad05619436af7cbd3f917c34f6ca5bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a85274f828c947323ae9270ccd7cd4b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#ga0a85274f828c947323ae9270ccd7cd4b">u8_t</a> = std::uint8_t</td></tr>
<tr class="separator:ga0a85274f828c947323ae9270ccd7cd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64d2269a915666c51cc67c222d8c7ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#gae64d2269a915666c51cc67c222d8c7ac">u16_t</a> = std::uint16_t</td></tr>
<tr class="separator:gae64d2269a915666c51cc67c222d8c7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad859103da019c24293b8635dd2389e07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#gad859103da019c24293b8635dd2389e07">u32_t</a> = std::uint32_t</td></tr>
<tr class="separator:gad859103da019c24293b8635dd2389e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03c2cbf35a6254c958cacd6c320d7df2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#ga03c2cbf35a6254c958cacd6c320d7df2">u64_t</a> = std::uint64_t</td></tr>
<tr class="separator:ga03c2cbf35a6254c958cacd6c320d7df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61fa1cb60edd576a0378ea33047f781"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#gab61fa1cb60edd576a0378ea33047f781">s8_t</a> = std::int8_t</td></tr>
<tr class="separator:gab61fa1cb60edd576a0378ea33047f781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae44971ee28f8a6e4b84d7f6b5466ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#ga9ae44971ee28f8a6e4b84d7f6b5466ef">s16_t</a> = std::int16_t</td></tr>
<tr class="separator:ga9ae44971ee28f8a6e4b84d7f6b5466ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fb83ae9ec3d1ef3818b9a07d399af5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#ga05fb83ae9ec3d1ef3818b9a07d399af5">s32_t</a> = std::int32_t</td></tr>
<tr class="separator:ga05fb83ae9ec3d1ef3818b9a07d399af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4310387e7196e1a6e98c65c70b36b1bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__integers.html#ga4310387e7196e1a6e98c65c70b36b1bb">s64_t</a> = std::int64_t</td></tr>
<tr class="separator:ga4310387e7196e1a6e98c65c70b36b1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174259c00f483468ce7c2194c0c5942e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____d3bf5147__2b5f__4bd4__bf99__76cf5b9932af.html#ga174259c00f483468ce7c2194c0c5942e">r32_t</a> = float</td></tr>
<tr class="separator:ga174259c00f483468ce7c2194c0c5942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33400af9a849521942e8a6f1ce66512b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____d3bf5147__2b5f__4bd4__bf99__76cf5b9932af.html#ga33400af9a849521942e8a6f1ce66512b">r64_t</a> = double</td></tr>
<tr class="separator:ga33400af9a849521942e8a6f1ce66512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fd570a4221f5e5e4d536d101b91779"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____d3bf5147__2b5f__4bd4__bf99__76cf5b9932af.html#ga13fd570a4221f5e5e4d536d101b91779">real_t</a> = <a class="el" href="group____d3bf5147__2b5f__4bd4__bf99__76cf5b9932af.html#ga33400af9a849521942e8a6f1ce66512b">r64_t</a></td></tr>
<tr class="memdesc:ga13fd570a4221f5e5e4d536d101b91779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the <a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b" title="The largest natural type available, the processor&#39;s word.">nkr::word_t</a> of the machine by selecting r32_t for 32-bit or r64_t for 64-bit.  <a href="group____d3bf5147__2b5f__4bd4__bf99__76cf5b9932af.html#ga13fd570a4221f5e5e4d536d101b91779">More...</a><br /></td></tr>
<tr class="separator:ga13fd570a4221f5e5e4d536d101b91779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6938f0fd61eac987b89d3207836a458b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b">word_t</a> = <a class="el" href="group__intrinsics__integers.html#ga03c2cbf35a6254c958cacd6c320d7df2">u64_t</a></td></tr>
<tr class="memdesc:ga6938f0fd61eac987b89d3207836a458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest natural type available, the processor's word.  <a href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b">More...</a><br /></td></tr>
<tr class="separator:ga6938f0fd61eac987b89d3207836a458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga581bf6978a7ad3105e61703a2e0e555a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga581bf6978a7ad3105e61703a2e0e555a">unsigned_word_t</a> = <a class="el" href="group__intrinsics__integers.html#ga03c2cbf35a6254c958cacd6c320d7df2">u64_t</a></td></tr>
<tr class="separator:ga581bf6978a7ad3105e61703a2e0e555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d40c7808c5b92d36990e89f3560fe89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga4d40c7808c5b92d36990e89f3560fe89">signed_word_t</a> = <a class="el" href="group__intrinsics__integers.html#ga4310387e7196e1a6e98c65c70b36b1bb">s64_t</a></td></tr>
<tr class="separator:ga4d40c7808c5b92d36990e89f3560fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8160404f5568b12b1b5163796d259d12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga8160404f5568b12b1b5163796d259d12">byte_t</a> = <a class="el" href="group__intrinsics__integers.html#ga0a85274f828c947323ae9270ccd7cd4b">u8_t</a></td></tr>
<tr class="memdesc:ga8160404f5568b12b1b5163796d259d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The smallest natural type available.  <a href="group__intrinsics__contextuals.html#ga8160404f5568b12b1b5163796d259d12">More...</a><br /></td></tr>
<tr class="separator:ga8160404f5568b12b1b5163796d259d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87710d101176846a1c5f0874dc403aff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga87710d101176846a1c5f0874dc403aff">size_t</a> = <a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b">word_t</a></td></tr>
<tr class="memdesc:ga87710d101176846a1c5f0874dc403aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for byte counts exclusively.  <a href="group__intrinsics__contextuals.html#ga87710d101176846a1c5f0874dc403aff">More...</a><br /></td></tr>
<tr class="separator:ga87710d101176846a1c5f0874dc403aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962bdb5ad1c5bc05d87739e09df6082b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> = <a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b">word_t</a></td></tr>
<tr class="memdesc:ga962bdb5ad1c5bc05d87739e09df6082b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for unit counts of any arbitrary type.  <a href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">More...</a><br /></td></tr>
<tr class="separator:ga962bdb5ad1c5bc05d87739e09df6082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd45a8ee0ce155f841b4cadb25d9b4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#gafcd45a8ee0ce155f841b4cadb25d9b4f">index_t</a> = <a class="el" href="group__intrinsics__contextuals.html#ga6938f0fd61eac987b89d3207836a458b">word_t</a></td></tr>
<tr class="memdesc:gafcd45a8ee0ce155f841b4cadb25d9b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for unit indices of any arbitrary array of types.  <a href="group__intrinsics__contextuals.html#gafcd45a8ee0ce155f841b4cadb25d9b4f">More...</a><br /></td></tr>
<tr class="separator:gafcd45a8ee0ce155f841b4cadb25d9b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9a380f784247ec4046f20b262f0b23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intrinsics__contextuals.html#ga1e9a380f784247ec4046f20b262f0b23">address_t</a> = std::uintptr_t</td></tr>
<tr class="memdesc:ga1e9a380f784247ec4046f20b262f0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for literal pointer math.  <a href="group__intrinsics__contextuals.html#ga1e9a380f784247ec4046f20b262f0b23">More...</a><br /></td></tr>
<tr class="separator:ga1e9a380f784247ec4046f20b262f0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >With the exception of "nkr_" prefixed macros, all other nkr entities are defined in this namespace.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac2fadabeca6af1088b2114f4b32cc63f" name="ac2fadabeca6af1088b2114f4b32cc63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fadabeca6af1088b2114f4b32cc63f">&#9670;&nbsp;</a></span>t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type_p &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">nkr::t</a> = typedef nkr::$tr::ts&lt;AND_tg, nkr::tuple::types_t&lt;type_p&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A way to wrap a single type for use with an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression, to differentiate it from a template. </p>

</div>
</div>
<a id="ae4babe1476e170123b9682b67160a0e8" name="ae4babe1476e170123b9682b67160a0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4babe1476e170123b9682b67160a0e8">&#9670;&nbsp;</a></span>ts</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nkr::generic_ ::tag::logic_gate_tr operator_p, typename ... types_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">nkr::ts</a> = typedef nkr::$tr::ts&lt;operator_p, nkr::tuple::types_t&lt;types_p...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A way to parenthesize and perform logical operations on several types in an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression. </p>

</div>
</div>
<a id="ad9ca1dc69cb9a052d8bc183cf5e69dcb" name="ad9ca1dc69cb9a052d8bc183cf5e69dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ca1dc69cb9a052d8bc183cf5e69dcb">&#9670;&nbsp;</a></span>tt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename ... &gt; typename template_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">nkr::tt</a> = typedef nkr::$tr::tts&lt;AND_tg, nkr::tuple::templates_t&lt;template_p&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A way to wrap a single template for use with an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression, to differentiate it from a type. </p>

</div>
</div>
<a id="aa41183e8bf88f05fd2c80a26fa6ebb52" name="aa41183e8bf88f05fd2c80a26fa6ebb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41183e8bf88f05fd2c80a26fa6ebb52">&#9670;&nbsp;</a></span>tts</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nkr::generic_ ::tag::logic_gate_tr operator_p, template&lt; typename ... &gt; typename ... templates_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">nkr::tts</a> = typedef nkr::$tr::tts&lt;operator_p, nkr::tuple::templates_t&lt;templates_p...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A way to parenthesize and perform logical operations on several templates in an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1898ff80c7081762a1840f00883fa258" name="a1898ff80c7081762a1840f00883fa258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1898ff80c7081762a1840f00883fa258">&#9670;&nbsp;</a></span>TR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nkr::ts_tr subjects_p, typename ... expression_parts_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr nkr::boolean::cpp_t nkr::TR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to filter a type by its qualifications, and by other types, templates, identities, and generics. </p>
<p >An integral function for the entire library. Any type or template that satisfies the nkr::interface::type_i or nkr::interface::template_i respectively can be used in conjunction with pre-defined operators to form an expression for use with this function. Input a group of subjects in addition to your arbitrary-length expression, and a compile-time or runtime boolean will be output indicating whether or not the subjects satisfy the expression.</p>
<dl class="section user"><dt>Purpose</dt><dd>The primary rationale for the existence of this function is to prevent the need of defining and redefining the same concepts over and over again with only minor variations. It keeps the focus on your static tests, and more importantly when using <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>, it keeps the focus on the signature of your types and functions, and what kind of types are acceptable inputs for their parameters.</dd></dl>
<dl class="section user"><dt>Grammatical Parts</dt><dd>A full <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression is made of two component parts, the <code>subject</code>, and an arbitrary number of <code>operators</code> paired with an <code>operand</code>: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">               <span class="comment">/* subject */</span></div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a>,</div>
<div class="line"> </div>
<div class="line">               <span class="comment">/* operator, operand */</span></div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacenkr_html"><div class="ttname"><a href="namespacenkr.html">nkr</a></div><div class="ttdef"><b>Definition:</b> array/cpp_t_dec.h:14</div></div>
<div class="ttc" id="anamespacenkr_html_a1898ff80c7081762a1840f00883fa258"><div class="ttname"><a href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">nkr::TR</a></div><div class="ttdeci">constexpr nkr::boolean::cpp_t TR() noexcept</div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div></div>
<div class="ttc" id="anamespacenkr_html_ac2fadabeca6af1088b2114f4b32cc63f"><div class="ttname"><a href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">nkr::t</a></div><div class="ttdeci">nkr::$tr::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:174</div></div>
</div><!-- fragment --> In the above example we statically asserted that <code>int</code> is <code>any</code> <code>int</code>. This time without comments: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implicit Operands</dt><dd>It is possible to use just a <code>subject</code> and an <code>operator</code> without use of an <code>operand</code>. This trivial example will always return true because <code>any</code> <code>subject</code> will always be <code>any</code> <code>subject</code>: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a>,</div>
<div class="line">                  any_tg</div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float&gt;</a>,</div>
<div class="line">                  any_tg</div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Qualification Operators</dt><dd>Implicit operands become critical for operators besides <code>any_tg</code>. Sometimes it is desireable to constrain a subject to qualification regardless of type: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a>,</div>
<div class="line">                  any_const_tg</div>
<div class="line">    &gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;const int&gt;</a>,</div>
<div class="line">                  any_const_tg</div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float&gt;</a>,</div>
<div class="line">                  any_const_tg</div>
<div class="line">    &gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;const float&gt;</a>,</div>
<div class="line">                  any_const_tg</div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> More commonly it is desirable to constrain to qualification and the type: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a>,</div>
<div class="line">                  any_const_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;const int&gt;</a>,</div>
<div class="line">                  any_const_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float&gt;</a>,</div>
<div class="line">                  any_const_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;const float&gt;</a>,</div>
<div class="line">                  any_const_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Template Operands</dt><dd>It is also possible to use templates. Here we simply constrain to an instantiated nkr::pointer::cpp_t, which will result in <code>true</code> because nkr::pointer::cpp_t&lt;int&gt; is an alias of <code>int*</code>: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int*&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;nkr::pointer::cpp_t&lt;int&gt;</a>&gt;</div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> Often it is useful to separate the template from its <code>inner type</code> which would be <code>int</code> in this case. This allows for more flexible expressions that make use of more than just the <code>any_tg</code> operator. Here we are asserting the same as above, that <code>int*</code> is <code>any</code> nkr::pointer::cpp_t <code>of any</code> <code>int</code>: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int*&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacenkr_html_ad9ca1dc69cb9a052d8bc183cf5e69dcb"><div class="ttname"><a href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">nkr::tt</a></div><div class="ttdeci">nkr::$tr::tts&lt; AND_tg, nkr::tuple::templates_t&lt; template_p &gt; &gt; tt</div><div class="ttdoc">A way to wrap a single template for use with an nkr::TR expression, to differentiate it from a type.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:187</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Tag Operands</dt><dd>Alternatively we can use a <code>ttg</code>, that is a <code>template tag</code> of nkr::pointer::cpp_t to achieve the same result: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int*&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_ttg&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> The use of <code>tags</code> can bring even more flexibility to an expression. For example, most templates provide a <code>tag</code> to test if a type is instantiated from it, regardless of the subject's actual <code>inner type</code>. Below we simply assert that the <code>subject</code> needs to be instantiated from <code>any</code> nkr::pointer::cpp_t by use of its <code>tg</code> or <code>type tag</code>: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int*&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;nkr::pointer::cpp_tg&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;float*&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;nkr::pointer::cpp_tg&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> Note the symetrical use of <code>tt</code> with <code>ttg</code> to constrain a <code>template tag</code> and <code>t</code> with <code>tg</code> to constrain a <code>type tag</code>.</dd></dl>
<dl class="section user"><dt>Type Wrappers and Template Wrappers</dt><dd>Types are wrapped with <a class="el" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f" title="A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.">nkr::t</a> or <a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8" title="A way to parenthesize and perform logical operations on several types in an nkr::TR expression.">nkr::ts</a>, that is <code>type</code> or <code>types</code> respectively. This syntactical feature differentiates between using a singluar type or multiple types in a subject or operand. It also differentiates between using types or templates as an operand. To use templates as an operand you would use <a class="el" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb" title="A way to wrap a single template for use with an nkr::TR expression, to differentiate it from a type.">nkr::tt</a> or <a class="el" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52" title="A way to parenthesize and perform logical operations on several templates in an nkr::TR expression.">nkr::tts</a>, that is 'template type' or 'template types' respectively. It is necessary to wrap the templates this way for the sake of arbitrary length expressions, which cannot be made up of both types and templates but only one or the other.</dd></dl>
<dl class="section user"><dt>Generic Operands</dt><dd><code>Tags</code> become absolutely critical when we start to introduce <code>generics</code> into our expressions.</dd></dl>
<dl class="section user"><dt>Arbitrary Length</dt><dd>Arbitrary length expressions allow for the constraint of templates of templates of templates, ..., of templates of types. Here we have an intentionally complex example: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int****&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> However it is possible to find real-world examples of two or even three operands in use with an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression throughout the library, with various templates and types coming into play. A classic C++ example would be an lvalue reference to a pointer which one might pass to a function for initialization: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_function" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258">TR</a>&lt;</div>
<div class="line">                  <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;const int* volatile&amp;&gt;</a>,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::reference::lvalue_t&gt;</a>,</div>
<div class="line">                  of_any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#ad9ca1dc69cb9a052d8bc183cf5e69dcb">tt&lt;nkr::pointer::cpp_t&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;int&gt;</a></div>
<div class="line">    &gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> In this case our function would not care what the pointer is pointing to, or that its <code>inner type</code> is <code>const</code>. It only cares that it is a reference to a pointer that is <code>non_const</code>, else it wouldn't be able to set it. It doesn't actualy care if the pointer is <code>volatile</code> or not because its functionality remains the same in that event.</dd></dl>
<dl class="section user"><dt>Target Operand</dt><dd>Finally, because the subject of <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> must always be a type and not a template, so too must the last operand be a type and not a template, even if that type is a <code>type tag</code> representing a template.</dd></dl>
<dl class="section user"><dt>Using Multiple Types as an Operand</dt><dd>Naturally there are times when using more than one type as a single operand in an <a class="el" href="namespacenkr.html#a1898ff80c7081762a1840f00883fa258" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::TR</a> expression is desirable. Sometimes one may wish to constrain to several operands parenthetically, to be evaluated by a logical operator. That's where <a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8" title="A way to parenthesize and perform logical operations on several types in an nkr::TR expression.">nkr::ts</a> comes in. </dd></dl>
<dl class="section user"><dt></dt><dd>Here we constrain to either type in the operand, with use of the nkr::OR_tg: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::negatable::integer_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;OR_tg, nkr::negatable::integer_t, nkr::negatable::real_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::negatable::real_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;OR_tg, nkr::negatable::integer_t, nkr::negatable::real_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespacenkr_html_ae4babe1476e170123b9682b67160a0e8"><div class="ttname"><a href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">nkr::ts</a></div><div class="ttdeci">nkr::$tr::ts&lt; operator_p, nkr::tuple::types_t&lt; types_p... &gt; &gt; ts</div><div class="ttdoc">A way to parenthesize and perform logical operations on several types in an nkr::TR expression.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:179</div></div>
</div><!-- fragment --> To both generics in the operand, with use of the nkr::AND_tg: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::negatable::integer_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;AND_tg, nkr::generic::negatable_tg, nkr::generic::number_tg&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::negatable::real_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;AND_tg, nkr::generic::negatable_tg, nkr::generic::number_tg&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --> To just one generic in the operand, with use of the nkr::XOR_tg: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::boolean::cpp_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;XOR_tg, nkr::generic::boolean_tg, nkr::generic::user_defined_tg&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::boolean::pure_t&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8">ts&lt;XOR_tg, nkr::generic::boolean_tg, nkr::generic::user_defined_tg&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Using Multiple Types as a Subject</dt><dd>You can also use <a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8" title="A way to parenthesize and perform logical operations on several types in an nkr::TR expression.">nkr::ts</a> for multiple subjects. Here we've built an entire set of truth tables where each subject is tested against the singular operand. Notice how the complement for each of the above operators is also in play here, namely nkr::NOR_tg, nkr::NAND_tg, and nkr::XNOR_tg: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> true_t = nkr::positive::integer_t;</div>
<div class="line">    <span class="keyword">using</span> false_t = nkr::negatable::integer_t;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;OR_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;OR_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;OR_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;OR_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;AND_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;AND_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;AND_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;AND_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, false_t, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XOR_tg, true_t, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NOR_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NOR_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NOR_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NOR_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NAND_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NAND_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NAND_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;NAND_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, false_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, true_t, false_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, false_t, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, false_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;ts&lt;XNOR_tg, true_t, true_t, true_t&gt;, any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;true_t&gt;</a>&gt;() == <span class="keyword">true</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Using Multiple Templates as an Operand</dt><dd>Following the pattern of postfixes, with <code>t</code> for type and <code>tt</code> for template of type, we also likewise use <a class="el" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52" title="A way to parenthesize and perform logical operations on several templates in an nkr::TR expression.">nkr::tts</a> instead of <a class="el" href="namespacenkr.html#ae4babe1476e170123b9682b67160a0e8" title="A way to parenthesize and perform logical operations on several types in an nkr::TR expression.">nkr::ts</a> to make use of multiple templates in an operand: <div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::positive::integer_t*&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">tts&lt;OR_tg, nkr::pointer::cpp_ttg, nkr::array::cpp_ttg&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;nkr::positive::integer_t&gt;</a>&gt;());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(TR&lt;t&lt;nkr::positive::integer_t[1]&gt;,</div>
<div class="line">                  any_tg, <a class="code hl_typedef" href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">tts&lt;OR_tg, nkr::pointer::cpp_ttg, nkr::array::cpp_ttg&gt;</a>,</div>
<div class="line">                  of_any_tg, <a class="code hl_typedef" href="namespacenkr.html#ac2fadabeca6af1088b2114f4b32cc63f">t&lt;nkr::positive::integer_t&gt;</a>&gt;());</div>
<div class="ttc" id="anamespacenkr_html_aa41183e8bf88f05fd2c80a26fa6ebb52"><div class="ttname"><a href="namespacenkr.html#aa41183e8bf88f05fd2c80a26fa6ebb52">nkr::tts</a></div><div class="ttdeci">nkr::$tr::tts&lt; operator_p, nkr::tuple::templates_t&lt; templates_p... &gt; &gt; tts</div><div class="ttdoc">A way to parenthesize and perform logical operations on several templates in an nkr::TR expression.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:192</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7e2b0a5823f1763322168ce5405ba455" name="a7e2b0a5823f1763322168ce5405ba455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2b0a5823f1763322168ce5405ba455">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a> nkr::operator== </td>
          <td>(</td>
          <td class="paramtype">built_in_tr auto&#160;</td>
          <td class="paramname"><em>built_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1none__t.html">none_t</a> &gt; auto&#160;</td>
          <td class="paramname"><em>none</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a47d72db753f1c18cb2ec4b3d4fbddfcb" name="a47d72db753f1c18cb2ec4b3d4fbddfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d72db753f1c18cb2ec4b3d4fbddfcb">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a> nkr::operator!= </td>
          <td>(</td>
          <td class="paramtype">built_in_tr auto&#160;</td>
          <td class="paramname"><em>built_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1none__t.html">none_t</a> &gt; auto&#160;</td>
          <td class="paramname"><em>none</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
