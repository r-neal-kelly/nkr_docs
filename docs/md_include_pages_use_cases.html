<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Use-Cases</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Use-Cases </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md29">nkr::tr</a><ul><li class="level2"><a href="#autotoc_md30">Dynamically Define Concepts In-Place</a></li>
<li class="level2"><a href="#autotoc_md31">Easy to Logically NOT Concepts</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >Examples of how <a class="el" href="namespacenkr.html">nkr</a> can be put to use.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
nkr::tr</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
Dynamically Define Concepts In-Place</h2>
<p >Let's take a concrete example. What if we wanted to have a function that takes two <code>std::vectors</code> and combines them? We do not care what their <code>value_types</code> are, only that the second one has a <code>value_type</code> statically convertible to the other. Let's put together a simple algorithm and not worry about exceptions and other validations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine(<span class="keyword">auto</span>&amp; vector_a, <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should move elements from vector_b to vector_a&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a{ 10.0f, 20.0f };</div>
<div class="line">    std::vector&lt;int&gt; vector_b{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 2);</div>
<div class="line">    CHECK(vector_b.size() == 2);</div>
<div class="line"> </div>
<div class="line">    Combine(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 4);</div>
<div class="line">    CHECK(vector_b.size() == 0);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a[0] == 10.0f);</div>
<div class="line">    CHECK(vector_a[1] == 20.0f);</div>
<div class="line">    CHECK(vector_a[2] == 30.0f);</div>
<div class="line">    CHECK(vector_a[3] == 40.0f);</div>
<div class="line">}</div>
</div><!-- fragment --><p >It works as expected, but only when we give it valid inputs. So how can we take advantage of C++20 concepts to improve the user-experience? We ought to give them better compiler errors than this one:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will give a compile error not very friendly towards the user of our function&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;size&#39;: is not a member of &#39;std::forward_list&lt;int,std::allocator&lt;int&gt;&gt;&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Actually, it might be tempting to change our algorithm so that <code>std::forward_list</code> will work too, but we want the algorithm that we have because it will be more performant with vectors and their <code>reserve</code> method. Maybe in the future we can add an overload for <code>std::forward_list</code> but for now we just want <code>std::vectors</code>. How about we try some duck-typing?:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>has_size =</div>
<div class="line">    <span class="keyword">requires</span>(type_p instance)</div>
<div class="line">{</div>
<div class="line">    { instance.size() } -&gt; std::same_as&lt;std::size_t&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Has_Size(has_size <span class="keyword">auto</span>&amp; vector_a, has_size <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should give a more user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: no matching overloaded function found</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: the associated constraints are not satisfied</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Works perfectly! Now the user cannot get a weird compiler message when they pass in a wrong type.</p>
<p >Right?:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, unordered_map);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;static_cast&#39;: cannot convert from &#39;std::pair&lt;const std::string,int&gt;&#39; to &#39;float&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >We surely need to react better for our user. Even if it seems like an edge case, we can never be too sure what our users will do:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>user_defined_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::size_t size()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 42;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will also not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    user_defined_t user_defined;</div>
<div class="line"> </div>
<div class="line">    CHECK(user_defined.size() == 42);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, user_defined);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;begin&#39;: is not a member of &#39;user_defined_t&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Something more than duck-typing has to be done. We could add more method checks but the problem still remains, it cannot guarantee that our user will pass a <code>std::vector</code>. Well, there must a way to constrain to a <code>std::vector</code> without constraining to its <code>value_type</code>. Actually there's more than one way to do it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector :</div>
<div class="line">    <span class="keyword">public</span> std::false_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_type, <span class="keyword">typename</span> allocator_type&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector&lt;std::vector&lt;value_type, allocator_type&gt;&gt; :</div>
<div class="line">    <span class="keyword">public</span> std::true_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_1 =</div>
<div class="line">    is_vector&lt;type_p&gt;::value;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_1(is_vector_1 <span class="keyword">auto</span>&amp; vector_a, is_vector_1 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >And here's a more concept-focused way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_2 = std::same_as&lt;</div>
<div class="line">    type_p,</div>
<div class="line">    std::vector&lt;typename type_p::value_type, typename type_p::allocator_type&gt;</div>
<div class="line">&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_2(is_vector_2 <span class="keyword">auto</span>&amp; vector_a, is_vector_2 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >As we can see they will both function correctly, but there's a couple of problems:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >While it's true that we want non-const <code>std::vectors</code> for our function, that is certainly not always going to be the case. Sometimes we actually want const and sometimes we may even want volatile types. Another issue is that it's not great having specific use-case concepts just laying about like this. In fact, it's really not great having concepts outside of our function at all. At the end of the day, we're not really interested in adding concepts to our code that will function in other contexts. We really just want our function to behave in a certain way. What we really want is to <b>dynamically define concepts in place</b>. Dynamic because we want to clarify qualification as well as type, and in place because we really just want it private to our particular function. And so we have <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                               <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill most of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list;</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;float&gt; const_vector_a;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int&gt; const_vector_b;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works beautifully</span></div>
<div class="line">    Combine_Non_Const_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// and all of these fail to compile: &quot;the associated constraints are not satisfied&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, forward_list);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, unordered_map);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(const_vector_a, vector_b);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, const_vector_b);</span></div>
<div class="line">}</div>
<div class="ttc" id="aconceptnkr_1_1tr_html"><div class="ttname"><a href="conceptnkr_1_1tr.html">nkr::tr</a></div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div><div class="ttdef"><b>Definition:</b> tr_dec.h:261</div></div>
<div class="ttc" id="anamespacenkr_html_a5b44c572847cc1f4d65122f867f3bdbf"><div class="ttname"><a href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt</a></div><div class="ttdeci">nkr::tr$::tts&lt; AND_tg, nkr::tuple::templates_t&lt; template_p &gt; &gt; tt</div><div class="ttdoc">A way to wrap a single template for use with an nkr::TR expression, to differentiate it from a type.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:188</div></div>
</div><!-- fragment --><p >There's just one thing missing. Let's add another private and dynamically defined in-place concept within our function body, to make sure that the inner types of the <code>std::vectors</code> are convertible:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Compatible_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                                          <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> vector_b_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;</div>
<div class="line">                  <span class="keyword">typename</span> vector_b_t::value_type,</div>
<div class="line">                  nkr::to_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;typename vector_a_t::value_type&gt;</a></div>
<div class="line">    &gt;, <span class="stringliteral">&quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill the rest of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::vector&lt;void*&gt; vector_c;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works perfectly</span></div>
<div class="line">    Combine_Non_Const_Compatible_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// fails with our error message: &quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Compatible_Vectors(vector_a, vector_c);</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacenkr_html_aecb8f05af8f5d93778ce60239336d8e3"><div class="ttname"><a href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t</a></div><div class="ttdeci">nkr::tr$::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:175</div></div>
</div><!-- fragment --><p >As we have seen, by using <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> we have cleanly and explicitly constrained our function as originally specified. Now we will truly only get non-const <code>std::vectors</code> passing through our function, all without having to statically define an exterior concept. We even use <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> to ensure that their <code>value_types</code> are compatible. And in the future if we decide to support other types such as <code>std::forward_list</code> we can easily do so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should work with non-const std::vectors or non-const std::forward_lists&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    std::forward_list&lt;float&gt; forward_list_a;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(forward_list_a, forward_list_b);</div>
<div class="line">}</div>
</div><!-- fragment --><p >And that's just scratching the surface of what <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> is capable of. With advanced usage we can constrain to multiple types and templates, their inner <code>value_types</code>, duck-typed generics, and even full-fledged interfaces all within a single expression.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Easy to Logically NOT Concepts</h2>
<p >Let's say we have a container class with two overloads for <code>Push_Back</code>, each of which accepts an object to add into our container. We have two overloads because we want the first one to copy lvalue references and the second one to move rvalue references. Because the lvalue reference overload has to make a copy, we allow any type that can be converted into an <code>element_t</code>, but with the rvalue reference overload we want to keep the argument explicitly moveable so that our function can't turn into a potentially hidden and expensive operation:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> result_e</div>
<div class="line">{</div>
<div class="line">    WILL_COPY,</div>
<div class="line">    WILL_CONVERT,</div>
<div class="line">    WILL_MOVE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    result_e Push_Back(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> argument_t = std::remove_cvref_t&lt;<span class="keyword">decltype</span>(element_to_copy_or_non_element_to_convert)&gt;;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::same_as&lt;argument_t, element_t&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_COPY;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_CONVERT;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_e Push_Back(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> result_e::WILL_MOVE;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should select the appropriate overload depending on the type and qualification&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_copy = 0;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_convert = 0;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    CHECK(container.Push_Back(element_to_copy) == result_e::WILL_COPY);</div>
<div class="line">    CHECK(container.Push_Back(other_to_convert) == result_e::WILL_CONVERT);</div>
<div class="line">    CHECK(container.Push_Back(std::move(element_to_move)) == result_e::WILL_MOVE);</div>
<div class="line">}</div>
</div><!-- fragment --><p >What happens if the user tries to move an instance that is not <code>element_t</code>?</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a confusing compile-time error if we try to move a non-element&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: result_e container_t&lt;__int64&gt;::Push_Back&lt;long&gt;(_T0 &amp;)&#39;: cannot convert argument 1 from &#39;long&#39; to &#39;_T0 &amp;&#39;</span></div>
<div class="line">    <span class="comment">// container.Push_Back(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Without going into the specifics of why this happens, the important take-away here is that the user is not being told what went wrong and may very well think our class is broken. After all he is trying to move an object and for some reason it's going to the copy overload. Furthermore a <code>long</code> can certainly be converted to a <code>long long</code> so maybe in the user's mind it should just work.</p>
<p >Now, there is really only way to fix this issue as it stands, and that is to add another overload that accepts the opposite of the input we want. We can either use the <code>delete</code> keyword to indicate that the new overload is unavailable, or we can define the overload with a static assert that explains to the user to why it's not available. In either case, we have a problem. How do we logically NOT our move <code>Push_Back</code> constraint?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: syntax error: &#39;!&#39;</span></div>
<div class="line">    <span class="comment">// void Push_Back(!std::same_as&lt;element_t&gt; auto&amp;&amp;) = delete;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >As we can see, the obvious solution does not work. In order to define the constraint in the class, we would have to use a totally different syntax. That syntax does solve the problem by producing a better compile-time error for the user, but it also introduces another user-facing problem and that is a more complex and non-symmetric method signature for our API:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// inconsist signature with the above method. It may not even be clear to the user that these two methods are related</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(type_p&amp;&amp;) <span class="keyword">requires</span> (!std::same_as&lt;type_p, element_t&gt;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a better compile-time error but a worse method signature&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Push_Back(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Thankfully we can clean that up too by defining an out of class concept instead:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b&gt;</div>
<div class="line"><span class="keyword">concept </span>not_same_as =</div>
<div class="line">    !std::same_as&lt;a, b&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(not_same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a better compile-time error but introduces out-of-class concepts to do it&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Push_Back(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Now in this simple case maybe it makes sense to have that static concept defined outside of the class because it can probably be used elsewhere. However, this pattern becomes untenable for every custom static concept you define. Does it really make sense to create an additional custom concept for every one you make, just because it could be logically inverted somewhere? For example, what if we actually want our move operator to work with another object that we know can be cheaply converted?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b, <span class="keyword">typename</span> c&gt;</div>
<div class="line"><span class="keyword">concept </span>same_as_either =</div>
<div class="line">    std::same_as&lt;a, b&gt; || std::same_as&lt;a, c&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b, <span class="keyword">typename</span> c&gt;</div>
<div class="line"><span class="keyword">concept </span>not_same_as_either =</div>
<div class="line">    !same_as_either&lt;a, b, c&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">class </span>cheap_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(same_as_either&lt;element_t, cheap_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Push_Back(not_same_as_either&lt;element_t, cheap_t&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p >We have to have a better solution than this. We're not really interested in defining concepts that will be used in other contexts, we just want our class to behave a certain way so it's not confusing to our user. We want our API to be easily readable especially at a glance when a user is just trying to get up and running. And maybe we want to easily change our classes methods in the future without worrying about other code that will have used our externally defined concepts. Hence we have <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">class </span>cheap_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    result_e Push_Back(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::to_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;element_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> argument_t = std::remove_cvref_t&lt;<span class="keyword">decltype</span>(element_to_copy_or_non_element_to_convert)&gt;;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::same_as&lt;argument_t, element_t&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_COPY;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_CONVERT;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_e Push_Back(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a38a1a30f12686b2cf6312cdc291277b1">nkr::ts&lt;nkr::OR_tg, element_t, cheap_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> result_e::WILL_MOVE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_e Push_Back(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::not_any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a38a1a30f12686b2cf6312cdc291277b1">nkr::ts&lt;nkr::AND_tg, element_t, cheap_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should allow for an easier to read API, correct overload resolution, and better compile-time errors&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_copy = 0;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_convert = 0;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_move = 0;</div>
<div class="line">    container_t&lt;long long&gt;::cheap_t cheap_to_use_in_move;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    CHECK(container.Push_Back(element_to_copy) == result_e::WILL_COPY);</div>
<div class="line">    CHECK(container.Push_Back(other_to_convert) == result_e::WILL_CONVERT);</div>
<div class="line">    CHECK(container.Push_Back(std::move(element_to_move)) == result_e::WILL_MOVE);</div>
<div class="line">    CHECK(container.Push_Back(std::move(cheap_to_use_in_move)) == result_e::WILL_MOVE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Push_Back(std::move(other_to_move));</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacenkr_html_a38a1a30f12686b2cf6312cdc291277b1"><div class="ttname"><a href="namespacenkr.html#a38a1a30f12686b2cf6312cdc291277b1">nkr::ts</a></div><div class="ttdeci">nkr::tr$::ts&lt; operator_p, nkr::tuple::types_t&lt; types_p... &gt; &gt; ts</div><div class="ttdoc">A way to parenthesize and perform logical operations on several types in an nkr::TR expression.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:180</div></div>
</div><!-- fragment --><p >So we see how <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> gives us the finer qualities of both C++ syntaxes used to constrain function parameters, but in a neater and more presentable way for our users. It allows us to more easily and cheaply invert our constraints that is more open to change and easier to distinguish from its complement. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
