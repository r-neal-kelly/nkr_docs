<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Use-Cases</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Use-Cases </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md30">nkr::tr</a><ul><li class="level2"><a href="#autotoc_md31">Dynamically Define Concepts In-Place</a></li>
<li class="level2"><a href="#autotoc_md33">Cleanly Negate Concepts</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >In-depth examples of how <a class="el" href="namespacenkr.html">nkr</a> can be put to use. If you are looking for short examples without prose, almost every entity has code samples in the <a href="namespaces.html">reference section</a>.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
nkr::tr</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Dynamically Define Concepts In-Place</h2>
<p >Let's take a concrete example. What if we wanted to have a function that takes two <code>std::vectors</code> and combines them? We do not care what their <code>value_types</code> are, only that the second one has a <code>value_type</code> statically convertible to the other. Let's put together a simple algorithm and not worry about exceptions and other validations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine(<span class="keyword">auto</span>&amp; vector_a, <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should move elements from vector_b to vector_a&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a{ 10.0f, 20.0f };</div>
<div class="line">    std::vector&lt;int&gt; vector_b{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 2);</div>
<div class="line">    CHECK(vector_b.size() == 2);</div>
<div class="line"> </div>
<div class="line">    Combine(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 4);</div>
<div class="line">    CHECK(vector_b.size() == 0);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a[0] == 10.0f);</div>
<div class="line">    CHECK(vector_a[1] == 20.0f);</div>
<div class="line">    CHECK(vector_a[2] == 30.0f);</div>
<div class="line">    CHECK(vector_a[3] == 40.0f);</div>
<div class="line">}</div>
</div><!-- fragment --><p >It works as expected, but only when we give it valid inputs. So how can we take advantage of C++20 concepts to improve the user-experience? We ought to give them better compiler errors than this one:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will give a compile error not very friendly towards the user of our function&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;size&#39;: is not a member of &#39;std::forward_list&lt;int,std::allocator&lt;int&gt;&gt;&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Actually, it might be tempting to change our algorithm so that <code>std::forward_list</code> will work too, but we want the algorithm that we have because it will be more performant with vectors and their <code>reserve</code> method. Maybe in the future we can add an overload for <code>std::forward_list</code> but for now we just want <code>std::vectors</code>. How about we try some duck-typing?:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>has_size =</div>
<div class="line">    <span class="keyword">requires</span>(type_p instance)</div>
<div class="line">{</div>
<div class="line">    { instance.size() } -&gt; std::same_as&lt;std::size_t&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Has_Size(has_size <span class="keyword">auto</span>&amp; vector_a, has_size <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should give a more user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: no matching overloaded function found</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: the associated constraints are not satisfied</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Works perfectly! Now the user cannot get a weird compiler message when they pass in a wrong type.</p>
<p >Right?:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, unordered_map);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;static_cast&#39;: cannot convert from &#39;std::pair&lt;const std::string,int&gt;&#39; to &#39;float&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >We surely need to react better for our user. Even if it seems like an edge case, we can never be too sure what our users will do:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>user_defined_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::size_t size()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 42;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will also not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    user_defined_t user_defined;</div>
<div class="line"> </div>
<div class="line">    CHECK(user_defined.size() == 42);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, user_defined);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;begin&#39;: is not a member of &#39;user_defined_t&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Something more than duck-typing has to be done. We could add more method checks but the problem still remains, it cannot guarantee that our user will pass a <code>std::vector</code>. Well, there must a way to constrain to a <code>std::vector</code> without constraining to its <code>value_type</code>. Actually there's more than one way to do it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector :</div>
<div class="line">    <span class="keyword">public</span> std::false_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_type, <span class="keyword">typename</span> allocator_type&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector&lt;std::vector&lt;value_type, allocator_type&gt;&gt; :</div>
<div class="line">    <span class="keyword">public</span> std::true_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_1 =</div>
<div class="line">    is_vector&lt;type_p&gt;::value;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_1(is_vector_1 <span class="keyword">auto</span>&amp; vector_a, is_vector_1 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >And here's a more concept-focused way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_2 = std::same_as&lt;</div>
<div class="line">    type_p,</div>
<div class="line">    std::vector&lt;typename type_p::value_type, typename type_p::allocator_type&gt;</div>
<div class="line">&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_2(is_vector_2 <span class="keyword">auto</span>&amp; vector_a, is_vector_2 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >As we can see they will both function correctly, but there's a couple of problems:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >While it's true that we want non-const <code>std::vectors</code> for our function, that is certainly not always going to be the case. Sometimes we actually want const and sometimes we may even want volatile types. Another issue is that it's not great having specific use-case concepts just laying about like this. In fact, it's really not great having concepts outside of our function at all. At the end of the day, we're not really interested in adding concepts to our code that will function in other contexts. We really just want our function to behave in a certain way. What we really want is to <b>dynamically define concepts in place</b>. Dynamic because we want to clarify qualification as well as type, and in place because we really just want it private to our particular function. And so we have <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                               <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill most of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list;</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;float&gt; const_vector_a;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int&gt; const_vector_b;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works beautifully</span></div>
<div class="line">    Combine_Non_Const_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// and all of these fail to compile: &quot;the associated constraints are not satisfied&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, forward_list);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, unordered_map);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(const_vector_a, vector_b);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, const_vector_b);</span></div>
<div class="line">}</div>
<div class="ttc" id="aconceptnkr_1_1tr_html"><div class="ttname"><a href="conceptnkr_1_1tr.html">nkr::tr</a></div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div><div class="ttdef"><b>Definition:</b> tr_dec.h:261</div></div>
<div class="ttc" id="anamespacenkr_html_a5b44c572847cc1f4d65122f867f3bdbf"><div class="ttname"><a href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt</a></div><div class="ttdeci">nkr::tr$::tts&lt; AND_tg, nkr::tuple::templates_t&lt; template_p &gt; &gt; tt</div><div class="ttdoc">A way to wrap a single template for use with an nkr::TR expression, to differentiate it from a type.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:188</div></div>
</div><!-- fragment --><p >There's just one thing missing. Let's add another private and dynamically defined in-place concept within our function body, to make sure that the inner types of the <code>std::vectors</code> are convertible:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Compatible_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                                          <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> vector_b_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;</div>
<div class="line">                  <span class="keyword">typename</span> vector_b_t::value_type,</div>
<div class="line">                  nkr::to_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;typename vector_a_t::value_type&gt;</a></div>
<div class="line">    &gt;, <span class="stringliteral">&quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill the rest of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::vector&lt;void*&gt; vector_c;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works perfectly</span></div>
<div class="line">    Combine_Non_Const_Compatible_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// fails with our error message: &quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Compatible_Vectors(vector_a, vector_c);</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacenkr_html_aecb8f05af8f5d93778ce60239336d8e3"><div class="ttname"><a href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t</a></div><div class="ttdeci">nkr::tr$::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:175</div></div>
</div><!-- fragment --><p >As we have seen, by using <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> we have cleanly and explicitly constrained our function as originally specified. Now we will truly only get non-const <code>std::vectors</code> passing through our function, all without having to statically define an exterior concept. We even use <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> to ensure that their <code>value_types</code> are compatible. And in the future if we decide to support other types such as <code>std::forward_list</code> we can easily do so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should work with non-const std::vectors or non-const std::forward_lists&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    std::forward_list&lt;float&gt; forward_list_a;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(forward_list_a, forward_list_b);</div>
<div class="line">}</div>
</div><!-- fragment --><p >And that's just scratching the surface of what <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> is capable of. With advanced usage we can constrain to multiple types and templates, their inner <code>value_types</code>, duck-typed generics, and even full-fledged interfaces all within a single expression.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md33"></a>
Cleanly Negate Concepts</h2>
<p >Let's say we have a container class with two overloads for an <code>Add</code> method, each of which accepts an element to add into our container. We have two overloads because we want the first one to copy lvalue references and the second one to move rvalue references. Because the lvalue reference overload has to make a copy, we allow any type that can be converted into an <code>element_t</code> through the method, but with the rvalue reference overload we want to keep the argument explicitly moveable so that our function can't turn into a potentially hidden and expensive operation:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> result_e</div>
<div class="line">{</div>
<div class="line">    WILL_COPY,</div>
<div class="line">    WILL_CONVERT,</div>
<div class="line">    WILL_MOVE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    result_e Add(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> argument_t = std::remove_cvref_t&lt;<span class="keyword">decltype</span>(element_to_copy_or_non_element_to_convert)&gt;;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::same_as&lt;argument_t, element_t&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_COPY;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> result_e::WILL_CONVERT;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    result_e Add(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> result_e::WILL_MOVE;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should select the appropriate overload depending on the type and qualification&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_copy = 0;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_convert = 0;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    CHECK(container.Add(element_to_copy) == result_e::WILL_COPY);</div>
<div class="line">    CHECK(container.Add(other_to_convert) == result_e::WILL_CONVERT);</div>
<div class="line">    CHECK(container.Add(std::move(element_to_move)) == result_e::WILL_MOVE);</div>
<div class="line">}</div>
</div><!-- fragment --><p >But what happens if the user tries to move an instance that is not an <code>element_t</code>?</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a confusing compile-time error when moving something other than element_t&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: result_e container_t&lt;__int64&gt;::Add&lt;long&gt;(_T0 &amp;)&#39;: cannot convert argument 1 from &#39;long&#39; to &#39;_T0 &amp;&#39;</span></div>
<div class="line">    <span class="comment">// container.Add(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Without going into the specifics of why this happens, the important take-away here is that the user is not being told what went wrong and may very well think our class is broken. After all they are trying to <em>move</em> an object, but for some reason it's going to the <em>copy</em> overload instead. Furthermore a <code>long</code> can certainly be converted to a <code>long long</code> so maybe in the user's mind it should just work.</p>
<p >Now there is really only one way to fix this issue as it stands, and that is to add another overload that constrains to the opposite of what we want. We can then use the <code>delete</code> keyword to indicate that the new overload is unavailable, or we can define the overload with a static assert that explains to the user why it's not available. In either case, we have a problem. How do we logically negate our constraint?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Add(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: syntax error: &#39;!&#39;</span></div>
<div class="line">    <span class="comment">// void Add(!std::same_as&lt;element_t&gt; auto&amp;&amp;) = delete;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >As we can see, the obvious solution does not work. We actually have to use a completely different syntax to negate the concept. Doing so will solve our original problem by producing a better compile-time error, but it will also introduce yet another user-oriented issue. Our API will become more complex with the introduction of a second syntax and less intuitive for our users to read:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Add(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Inconsist signature with the above method.</span></div>
<div class="line">    <span class="comment">// It may not even be clear to the user that these two methods are intricately related</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Add(type_p&amp;&amp;) <span class="keyword">requires</span> (!std::same_as&lt;type_p, element_t&gt;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a better compile-time error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Add(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Instead of using the different syntax, another option is to define a custom concept outside of the class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b&gt;</div>
<div class="line"><span class="keyword">concept </span>not_same_as =</div>
<div class="line">    !std::same_as&lt;a, b&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Add(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(std::same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(not_same_as&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will have a better compile-time error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Add(std::move(other_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Now in this simple case it might make sense to have a custom concept defined outside of the class because it can probably be used elsewhere. However, this pattern becomes burdensome for every concept we define. Does it really make sense to create an additional concept for every custom one we make, just because it could potentially be negated? For example, what if we want to change our custom concept to additionally constrain to non-const types? After all, if our container template accepts user-defined types as elements then we cannot move them when they are const:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b&gt;</div>
<div class="line"><span class="keyword">concept </span>same_as_non_const =</div>
<div class="line">    std::same_as&lt;a, b&gt; &amp;&amp; !std::is_const_v&lt;a&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> a, <span class="keyword">typename</span> b&gt;</div>
<div class="line"><span class="keyword">concept </span>not_same_as_non_const =</div>
<div class="line">    !same_as_non_const&lt;a, b&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Add(std::convertible_to&lt;element_t&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(same_as_non_const&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(not_same_as_non_const&lt;element_t&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p >We really want a better solution than this. We're not interested in defining concepts that will be used in other contexts, we just want our class to behave a certain way so it's not confusing for our users. We also want our API to be easily readable, and maybe in the future we'll want to make adjustments to our method's constraints without worrying about breaking someone else's code. Enter <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> element_p&gt;</div>
<div class="line"><span class="keyword">class </span>container_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> element_t = element_p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> Add(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::to_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;element_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; element_to_copy_or_non_element_to_convert)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;element_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; element_to_move)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Add(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::not_any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;element_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should have better compile-time errors, an easier to read API, and be more robust to change&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    container_t&lt;long long&gt; container;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_copy = 0;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_convert = 0;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> element_to_move = 0;</div>
<div class="line">    <span class="keywordtype">long</span> other_to_move = 0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> const_element_to_move = 0;</div>
<div class="line"> </div>
<div class="line">    container.Add(element_to_copy);</div>
<div class="line">    container.Add(other_to_convert);</div>
<div class="line">    container.Add(std::move(element_to_move));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Add(std::move(other_to_move));</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ERROR: attempting to reference a deleted function</span></div>
<div class="line">    <span class="comment">// container.Add(std::move(const_element_to_move));</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >So we see how <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> gives us neater, more readable, and more robust constraints which can easily be negated. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
