<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Use-Cases</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Use-Cases </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md31"></a>
nkr::tr</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Dynamically Define Concepts In-Place</h2>
<p >Let's take a concrete example. What if we wanted to have a function that takes two <code>std::vectors</code> and combines them? We do not care what their <code>value_types</code> are, only that the second one has a <code>value_type</code> statically convertible to the other. Let's put together a simple algorithm and not worry about exceptions and other validations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine(<span class="keyword">auto</span>&amp; vector_a, <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should move elements from vector_b to vector_a&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a{ 10.0f, 20.0f };</div>
<div class="line">    std::vector&lt;int&gt; vector_b{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 2);</div>
<div class="line">    CHECK(vector_b.size() == 2);</div>
<div class="line"> </div>
<div class="line">    Combine(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a.size() == 4);</div>
<div class="line">    CHECK(vector_b.size() == 0);</div>
<div class="line"> </div>
<div class="line">    CHECK(vector_a[0] == 10.0f);</div>
<div class="line">    CHECK(vector_a[1] == 20.0f);</div>
<div class="line">    CHECK(vector_a[2] == 30.0f);</div>
<div class="line">    CHECK(vector_a[3] == 40.0f);</div>
<div class="line">}</div>
</div><!-- fragment --><p >It works as expected, but only when we give it valid inputs. So how can we take advantage of C++20 concepts to improve the user-experience? We ought to give them better compiler errors than this one:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will give a compile error not very friendly towards the user of our function&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;size&#39;: is not a member of &#39;std::forward_list&lt;int,std::allocator&lt;int&gt;&gt;&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Actually, it might be tempting to change our algorithm so that <code>std::forward_list</code> will work too, but we want the algorithm that we have because it will be more performant with vectors and their <code>reserve</code> method. Maybe in the future we can add an overload for <code>std::forward_list</code> but for now we just want <code>std::vectors</code>. How about we try some duck-typing?:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>has_size =</div>
<div class="line">    <span class="keyword">requires</span>(type_p instance)</div>
<div class="line">{</div>
<div class="line">    { instance.size() } -&gt; std::same_as&lt;std::size_t&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Has_Size(has_size <span class="keyword">auto</span>&amp; vector_a, has_size <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should give a more user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list{ 30, 40 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, forward_list);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: no matching overloaded function found</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;Combine_If_Has_Size&#39;: the associated constraints are not satisfied</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Works perfectly! Now the user cannot get a weird compiler message when they pass in a wrong type.</p>
<p >Right?:</p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;will not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, unordered_map);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;static_cast&#39;: cannot convert from &#39;std::pair&lt;const std::string,int&gt;&#39; to &#39;float&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >We surely need to react better for our user. Even if it seems like an edge case, we can never be too sure what our users will do:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>user_defined_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::size_t size()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 42;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;will also not give a user-friendly compile error&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector{ 10.0f, 20.0f };</div>
<div class="line">    user_defined_t user_defined;</div>
<div class="line"> </div>
<div class="line">    CHECK(user_defined.size() == 42);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combine_If_Has_Size(vector, user_defined);</span></div>
<div class="line">    <span class="comment">// ERROR: &#39;begin&#39;: is not a member of &#39;user_defined_t&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Something more than duck-typing has to be done. We could add more method checks but the problem still remains, it cannot guarantee that our user will pass a <code>std::vector</code>. Well, there must a way to constrain to a <code>std::vector</code> without constraining to its <code>value_type</code>. Actually there's more than one way to do it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector :</div>
<div class="line">    <span class="keyword">public</span> std::false_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_type, <span class="keyword">typename</span> allocator_type&gt;</div>
<div class="line"><span class="keyword">struct </span>is_vector&lt;std::vector&lt;value_type, allocator_type&gt;&gt; :</div>
<div class="line">    <span class="keyword">public</span> std::true_type</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_1 =</div>
<div class="line">    is_vector&lt;type_p&gt;::value;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_1(is_vector_1 <span class="keyword">auto</span>&amp; vector_a, is_vector_1 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >And here's a more concept-focused way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>is_vector_2 = std::same_as&lt;</div>
<div class="line">    type_p,</div>
<div class="line">    std::vector&lt;typename type_p::value_type, typename type_p::allocator_type&gt;</div>
<div class="line">&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::vector&lt;int&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::forward_list&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;std::unordered_map&lt;std::string, int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;user_defined_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_If_Is_Vector_2(is_vector_2 <span class="keyword">auto</span>&amp; vector_a, is_vector_2 <span class="keyword">auto</span>&amp; vector_b);</div>
</div><!-- fragment --><p >As we can see they will both function correctly, but there's a couple of problems:</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(is_vector_1&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(is_vector_2&lt;const std::vector&lt;int&gt;&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >While it's true that we want non-const <code>std::vectors</code> for our function, that is certainly not always going to be the case. Sometimes we actually want const and sometimes we may even want volatile types. Another issue is that it's not great having specific use-case concepts just laying about like this. In fact, it's really not great having concepts outside of our function at all. At the end of the day, we're not really interested in adding concepts to our code that will function in other contexts. We really just want our function to behave in a certain way. What we really want is to <b>dynamically define concepts in place</b>. Dynamic because we want to clarify qualification as well as type, and in place because we really just want it private to our particular function. And so we have <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                               <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill most of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list;</div>
<div class="line">    std::unordered_map&lt;std::string, int&gt; unordered_map;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;float&gt; const_vector_a;</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int&gt; const_vector_b;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works beautifully</span></div>
<div class="line">    Combine_Non_Const_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// and all of these fail to compile: &quot;the associated constraints are not satisfied&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, forward_list);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, unordered_map);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(const_vector_a, vector_b);</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Vectors(vector_a, const_vector_b);</span></div>
<div class="line">}</div>
<div class="ttc" id="aconceptnkr_1_1tr_html"><div class="ttname"><a href="conceptnkr_1_1tr.html">nkr::tr</a></div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div><div class="ttdef"><b>Definition:</b> tr_dec.h:261</div></div>
<div class="ttc" id="anamespacenkr_html_a5b44c572847cc1f4d65122f867f3bdbf"><div class="ttname"><a href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt</a></div><div class="ttdeci">nkr::tr$::tts&lt; AND_tg, nkr::tuple::templates_t&lt; template_p &gt; &gt; tt</div><div class="ttdoc">A way to wrap a single template for use with an nkr::TR expression, to differentiate it from a type.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:188</div></div>
</div><!-- fragment --><p >There's just one thing missing. Let's add another private and dynamically defined in-place concept within our function body, to make sure that the inner types of the <code>std::vectors</code> are convertible:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_Non_Const_Compatible_Vectors(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                                          <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vector_a_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> vector_b_t = std::remove_reference_t&lt;<span class="keyword">decltype</span>(vector_b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;</div>
<div class="line">                  <span class="keyword">typename</span> vector_b_t::value_type,</div>
<div class="line">                  nkr::to_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;typename vector_a_t::value_type&gt;</a></div>
<div class="line">    &gt;, <span class="stringliteral">&quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    vector_a.reserve(vector_a.size() + vector_b.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> itr = vector_b.begin(); itr != vector_b.end(); ++itr) {</div>
<div class="line">        vector_a.push_back(<span class="keyword">static_cast&lt;</span>typename vector_a_t::value_type<span class="keyword">&gt;</span>(*itr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    vector_b.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should fulfill the rest of our design specifications&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line">    std::vector&lt;void*&gt; vector_c;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// works perfectly</span></div>
<div class="line">    Combine_Non_Const_Compatible_Vectors(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// fails with our error message: &quot;the values of vector_b cannot be converted to the value_type of vector_a&quot;</span></div>
<div class="line">    <span class="comment">// Combine_Non_Const_Compatible_Vectors(vector_a, vector_c);</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacenkr_html_aecb8f05af8f5d93778ce60239336d8e3"><div class="ttname"><a href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t</a></div><div class="ttdeci">nkr::tr$::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:175</div></div>
</div><!-- fragment --><p >As we have seen, by using <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> we have cleanly and explicitly constrained our function as originally specified. Now we will truly only get non-const <code>std::vectors</code> passing through our function, all without having to statically define an exterior concept. We even use <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> to ensure that their <code>value_types</code> are compatible. And in the future if we decide to support other types such as <code>std::forward_list</code> we can easily do so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::vector&gt;</a>&gt; <span class="keyword">auto</span>&amp; vector_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Combine_With_Overloads(<a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_a,</div>
<div class="line">                            <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_non_const_tg, <a class="code hl_typedef" href="namespacenkr.html#a5b44c572847cc1f4d65122f867f3bdbf">nkr::tt&lt;std::forward_list&gt;</a>&gt; <span class="keyword">auto</span>&amp; forward_list_b)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE(<span class="stringliteral">&quot;should work with non-const std::vectors or non-const std::forward_lists&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;float&gt; vector_a;</div>
<div class="line">    std::vector&lt;int&gt; vector_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(vector_a, vector_b);</div>
<div class="line"> </div>
<div class="line">    std::forward_list&lt;float&gt; forward_list_a;</div>
<div class="line">    std::forward_list&lt;int&gt; forward_list_b;</div>
<div class="line"> </div>
<div class="line">    Combine_With_Overloads(forward_list_a, forward_list_b);</div>
<div class="line">}</div>
</div><!-- fragment --><p >And that's just scratching the surface of what <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> is capable of. With advanced usage we can constrain to multiple types and templates, their inner <code>value_types</code>, duck-typed generics, and even full-fledged interfaces all within a single expression. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
