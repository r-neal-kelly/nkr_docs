<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: nkr::allocator::heap_t&lt; unit_p &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language, an extensible string, and more, all developed alongside a comprehensive test suite.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenkr.html">nkr</a></li><li class="navelem"><a class="el" href="namespacenkr_1_1allocator.html">allocator</a></li><li class="navelem"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classnkr_1_1allocator_1_1heap__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nkr::allocator::heap_t&lt; unit_p &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">aliases</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp9299da2529c98fccce0e32b476ba3266"></a></p>
</td></tr>
<tr class="memitem:a5c30b02946b76ad8f35b800510ca8358"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a5c30b02946b76ad8f35b800510ca8358">unit_t</a> = unit_p</td></tr>
<tr class="memdesc:a5c30b02946b76ad8f35b800510ca8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type which space will be allocated for.  <a href="classnkr_1_1allocator_1_1heap__t.html#a5c30b02946b76ad8f35b800510ca8358">More...</a><br /></td></tr>
<tr class="separator:a5c30b02946b76ad8f35b800510ca8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d87d62b8d22b78e06211a5db68178"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> = unit_p *</td></tr>
<tr class="memdesc:aaf8d87d62b8d22b78e06211a5db68178"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard C pointer of unit_t which works with this allocator.  <a href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">More...</a><br /></td></tr>
<tr class="separator:aaf8d87d62b8d22b78e06211a5db68178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2dcc75aaf1f828b639e74b684bece"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> = <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a>&lt; unit_p &gt;</td></tr>
<tr class="memdesc:a3ed2dcc75aaf1f828b639e74b684bece"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classnkr_1_1pointer__t.html">pointer_t</a> which works with this allocator.  <a href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">More...</a><br /></td></tr>
<tr class="separator:a3ed2dcc75aaf1f828b639e74b684bece"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">static functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp8c3f72e9294cec463e684a83536b8c09"></a></p>
</td></tr>
<tr class="memitem:a52e688b3bdafbc14968d98df8a8c9feb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a52e688b3bdafbc14968d98df8a8c9feb">Min_Unit_Count</a> ()</td></tr>
<tr class="memdesc:a52e688b3bdafbc14968d98df8a8c9feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used by this particular allocator. Always equals to 0.  <a href="classnkr_1_1allocator_1_1heap__t.html#a52e688b3bdafbc14968d98df8a8c9feb">More...</a><br /></td></tr>
<tr class="separator:a52e688b3bdafbc14968d98df8a8c9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629">Max_Unit_Count</a> ()</td></tr>
<tr class="memdesc:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum number of objects which space can be allocated for.  <a href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629">More...</a><br /></td></tr>
<tr class="separator:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29fbcc4d58328d545b39b21e43c13da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#ac29fbcc4d58328d545b39b21e43c13da">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count)</td></tr>
<tr class="memdesc:ac29fbcc4d58328d545b39b21e43c13da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#ac29fbcc4d58328d545b39b21e43c13da">More...</a><br /></td></tr>
<tr class="separator:ac29fbcc4d58328d545b39b21e43c13da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c4c4dcf6d44fb45b55c3314503e099"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a58c4c4dcf6d44fb45b55c3314503e099">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count)</td></tr>
<tr class="memdesc:a58c4c4dcf6d44fb45b55c3314503e099"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a58c4c4dcf6d44fb45b55c3314503e099">More...</a><br /></td></tr>
<tr class="separator:a58c4c4dcf6d44fb45b55c3314503e099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b15015b4e08af470af295d8d6a9f06"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#ac7b15015b4e08af470af295d8d6a9f06">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count)</td></tr>
<tr class="memdesc:ac7b15015b4e08af470af295d8d6a9f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#ac7b15015b4e08af470af295d8d6a9f06">More...</a><br /></td></tr>
<tr class="separator:ac7b15015b4e08af470af295d8d6a9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3fb9c5bf1fe4f90193d2b047634cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a36f3fb9c5bf1fe4f90193d2b047634cc">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count)</td></tr>
<tr class="memdesc:a36f3fb9c5bf1fe4f90193d2b047634cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a36f3fb9c5bf1fe4f90193d2b047634cc">More...</a><br /></td></tr>
<tr class="separator:a36f3fb9c5bf1fe4f90193d2b047634cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceedaafffb43bd38cded5248a7983c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#acceedaafffb43bd38cded5248a7983c0">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units)</td></tr>
<tr class="memdesc:acceedaafffb43bd38cded5248a7983c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#acceedaafffb43bd38cded5248a7983c0">More...</a><br /></td></tr>
<tr class="separator:acceedaafffb43bd38cded5248a7983c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d822c6c2d104c145e215a56084249d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a9d822c6c2d104c145e215a56084249d2">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units)</td></tr>
<tr class="memdesc:a9d822c6c2d104c145e215a56084249d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a9d822c6c2d104c145e215a56084249d2">More...</a><br /></td></tr>
<tr class="separator:a9d822c6c2d104c145e215a56084249d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;any_type_tr unit_p&gt;<br />
class nkr::allocator::heap_t&lt; unit_p &gt;</div><p >A wrapper for the <a class="el" href="namespacenkr_1_1os_1_1heap.html">nkr::os::heap</a> allocator, often used by other types around the library as their default allocator.</p>
<p >In addition to working directly with C pointers, in order to satisfy the <a class="el" href="conceptnkr_1_1allocator__i.html" title="Defines common functionality that must exist on an allocator implementation for use in nkr.">nkr::allocator_i</a> this also handles <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a> objects, correctly setting their unit counts after operating upon them. The primary purpose of this type and others like it is to provide an interchangable set of allocators with which to use with other types around the library, for example nkr::array::dynamic_t. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5c30b02946b76ad8f35b800510ca8358" name="a5c30b02946b76ad8f35b800510ca8358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c30b02946b76ad8f35b800510ca8358">&#9670;&nbsp;</a></span>unit_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::unit_t =  unit_p</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying type which space will be allocated for. </p>

</div>
</div>
<a id="aaf8d87d62b8d22b78e06211a5db68178" name="aaf8d87d62b8d22b78e06211a5db68178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d87d62b8d22b78e06211a5db68178">&#9670;&nbsp;</a></span>units_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::units_t =  unit_p*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard C pointer of unit_t which works with this allocator. </p>

</div>
</div>
<a id="a3ed2dcc75aaf1f828b639e74b684bece" name="a3ed2dcc75aaf1f828b639e74b684bece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2dcc75aaf1f828b639e74b684bece">&#9670;&nbsp;</a></span>pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::pointer_t =  <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a>&lt;unit_p&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classnkr_1_1pointer__t.html">pointer_t</a> which works with this allocator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a52e688b3bdafbc14968d98df8a8c9feb" name="a52e688b3bdafbc14968d98df8a8c9feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e688b3bdafbc14968d98df8a8c9feb">&#9670;&nbsp;</a></span>Min_Unit_Count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Min_Unit_Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not used by this particular allocator. Always equals to 0. </p>

</div>
</div>
<a id="a0c77d45a11cb4487b21a96d2aa4b6629" name="a0c77d45a11cb4487b21a96d2aa4b6629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c77d45a11cb4487b21a96d2aa4b6629">&#9670;&nbsp;</a></span>Max_Unit_Count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Max_Unit_Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum number of objects which space can be allocated for. </p>
<p >This limitation exists due to the size of the word_t of the machine and the physical limits of memory address space. Very improbable to reach with a 64-bit processor but 32-bit is a different story, with limitations of just under 4 gigabytes of allocatable space. For convenience, the unit_t is the basis of the metric rather than bytes. </p>

</div>
</div>
<a id="ac29fbcc4d58328d545b39b21e43c13da" name="ac29fbcc4d58328d545b39b21e43c13da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29fbcc4d58328d545b39b21e43c13da">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write a new address to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a58c4c4dcf6d44fb45b55c3314503e099" name="a58c4c4dcf6d44fb45b55c3314503e099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c4c4dcf6d44fb45b55c3314503e099">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a> that this function can write a new address and unit count to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="ac7b15015b4e08af470af295d8d6a9f06" name="ac7b15015b4e08af470af295d8d6a9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b15015b4e08af470af295d8d6a9f06">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write a new address to. The qualification of the unit_t itself does not matter. You can also use this function to allocate by passing a nullptr. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a> for more information.</td></tr>
    <tr><td class="paramname">new_unit_count</td><td>is the number of unit_t objects for which to allocate space. You can also use this function to deallocate by passing a zero count. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a36f3fb9c5bf1fe4f90193d2b047634cc" name="a36f3fb9c5bf1fe4f90193d2b047634cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f3fb9c5bf1fe4f90193d2b047634cc">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write a new address to. The qualification of the unit_t itself does not matter. You can also use this function to allocate by passing a nullptr. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a> for more information.</td></tr>
    <tr><td class="paramname">new_unit_count</td><td>is the number of unit_t objects for which to allocate space. You can also use this function to deallocate by passing a zero count. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="acceedaafffb43bd38cded5248a7983c0" name="acceedaafffb43bd38cded5248a7983c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceedaafffb43bd38cded5248a7983c0">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write nullptr to after deallocating. The qualification of the unit_t itself does not matter. If given nullptr it will return without issue. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d822c6c2d104c145e215a56084249d2" name="a9d822c6c2d104c145e215a56084249d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d822c6c2d104c145e215a56084249d2">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html">nkr::pointer_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write nullptr to after deallocating. The qualification of the unit_t itself does not matter. If given nullptr it will return without issue. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
