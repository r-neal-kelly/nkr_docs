<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: nkr::allocator::heap_t&lt; unit_p &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">My C++20 library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenkr.html">nkr</a></li><li class="navelem"><b>allocator</b></li><li class="navelem"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classnkr_1_1allocator_1_1heap__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nkr::allocator::heap_t&lt; unit_p &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A wrapper for the <a class="el" href="namespacenkr_1_1os_1_1heap.html" title="Functions that interface with memory located on the heap. Primarily, this is an extension of the stan...">nkr::os::heap</a> allocator, often used by other types around the library as the default allocator.  
 <a href="classnkr_1_1allocator_1_1heap__t.html#details">More...</a></p>

<p><code>#include &quot;heap_t_dec.h&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">aliases</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp9299da2529c98fccce0e32b476ba3266"></a></p>
</td></tr>
<tr class="memitem:a5c30b02946b76ad8f35b800510ca8358"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a5c30b02946b76ad8f35b800510ca8358">unit_t</a> = unit_p</td></tr>
<tr class="memdesc:a5c30b02946b76ad8f35b800510ca8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type which space will be allocated for.  <a href="classnkr_1_1allocator_1_1heap__t.html#a5c30b02946b76ad8f35b800510ca8358">More...</a><br /></td></tr>
<tr class="separator:a5c30b02946b76ad8f35b800510ca8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d87d62b8d22b78e06211a5db68178"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> = unit_p *</td></tr>
<tr class="memdesc:aaf8d87d62b8d22b78e06211a5db68178"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard C pointer of unit_t which works with this allocator.  <a href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">More...</a><br /></td></tr>
<tr class="separator:aaf8d87d62b8d22b78e06211a5db68178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2dcc75aaf1f828b639e74b684bece"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> = <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a>&lt; unit_p &gt;</td></tr>
<tr class="memdesc:a3ed2dcc75aaf1f828b639e74b684bece"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">pointer_t</a> which works with this allocator.  <a href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">More...</a><br /></td></tr>
<tr class="separator:a3ed2dcc75aaf1f828b639e74b684bece"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">static functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp8c3f72e9294cec463e684a83536b8c09"></a></p>
</td></tr>
<tr class="memitem:a52e688b3bdafbc14968d98df8a8c9feb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a52e688b3bdafbc14968d98df8a8c9feb">Min_Unit_Count</a> ()</td></tr>
<tr class="memdesc:a52e688b3bdafbc14968d98df8a8c9feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used by this particular allocator. Always equals to 0.  <a href="classnkr_1_1allocator_1_1heap__t.html#a52e688b3bdafbc14968d98df8a8c9feb">More...</a><br /></td></tr>
<tr class="separator:a52e688b3bdafbc14968d98df8a8c9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629">Max_Unit_Count</a> ()</td></tr>
<tr class="memdesc:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the maximum number of objects which space can be allocated for.  <a href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629">More...</a><br /></td></tr>
<tr class="separator:a0c77d45a11cb4487b21a96d2aa4b6629"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">friends</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp28f20a02bf8a021fab4fcec48afb584e"></a></p>
</td></tr>
<tr class="memitem:a1aae4bf469928b2883177e7ceba11ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a1aae4bf469928b2883177e7ceba11ed8">operator==</a> (is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto a, is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto b)</td></tr>
<tr class="memdesc:a1aae4bf469928b2883177e7ceba11ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares any qualified or unqualifed version of the type.  <a href="classnkr_1_1allocator_1_1heap__t.html#a1aae4bf469928b2883177e7ceba11ed8">More...</a><br /></td></tr>
<tr class="separator:a1aae4bf469928b2883177e7ceba11ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe9d3d9505148cd1ae4daefddf84c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#affe9d3d9505148cd1ae4daefddf84c8b">operator!=</a> (is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto a, is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto b)</td></tr>
<tr class="memdesc:affe9d3d9505148cd1ae4daefddf84c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares any qualified or unqualifed version of the type.  <a href="classnkr_1_1allocator_1_1heap__t.html#affe9d3d9505148cd1ae4daefddf84c8b">More...</a><br /></td></tr>
<tr class="separator:affe9d3d9505148cd1ae4daefddf84c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">objects</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp5891da2d64975cae48d175d1e001f5da"></a>Because this is a static allocator and it doesn't need its own memory footprint, all of these are simply here to fulfill the nkr::allocator_i and do not do anything.</p>
</td></tr>
<tr class="memitem:a931f6bd0663a5452688b15081e65edff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a931f6bd0663a5452688b15081e65edff">heap_t</a> ()=default</td></tr>
<tr class="separator:a931f6bd0663a5452688b15081e65edff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a1093199a2cfef563309491cb5e18d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#ac5a1093199a2cfef563309491cb5e18d">heap_t</a> (const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other)</td></tr>
<tr class="separator:ac5a1093199a2cfef563309491cb5e18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96180f4b14b62792b6fa50d9bfe1a185"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a96180f4b14b62792b6fa50d9bfe1a185">heap_t</a> (const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other)</td></tr>
<tr class="separator:a96180f4b14b62792b6fa50d9bfe1a185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9939b6a738a297d92de0675aa7bf6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aff9939b6a738a297d92de0675aa7bf6c">heap_t</a> (<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:aff9939b6a738a297d92de0675aa7bf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0303b3bdd4805989f73a755e72202f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a4b0303b3bdd4805989f73a755e72202f">heap_t</a> (volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a4b0303b3bdd4805989f73a755e72202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a10a21c59285871d4e642e5a76729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a4c8a10a21c59285871d4e642e5a76729">operator=</a> (const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other)</td></tr>
<tr class="separator:a4c8a10a21c59285871d4e642e5a76729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4615cbc2b80da368b0ec508d26d56f0"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#ab4615cbc2b80da368b0ec508d26d56f0">operator=</a> (const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other) volatile</td></tr>
<tr class="separator:ab4615cbc2b80da368b0ec508d26d56f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6ae27be87aebc8543e3135ebc79e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0b6ae27be87aebc8543e3135ebc79e5e">operator=</a> (const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other)</td></tr>
<tr class="separator:a0b6ae27be87aebc8543e3135ebc79e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe8a0a10b0c74d9b76ba91e399d58c3"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#affe8a0a10b0c74d9b76ba91e399d58c3">operator=</a> (const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;other) volatile</td></tr>
<tr class="separator:affe8a0a10b0c74d9b76ba91e399d58c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221db75d1fc3fabe90062fcb50f9db22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a221db75d1fc3fabe90062fcb50f9db22">operator=</a> (<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a221db75d1fc3fabe90062fcb50f9db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790dba58d376ee2534a26dedb582507"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a8790dba58d376ee2534a26dedb582507">operator=</a> (<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&amp;other) volatile noexcept</td></tr>
<tr class="separator:a8790dba58d376ee2534a26dedb582507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f98755573b1d8a69acd1f4e2639fa6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a5f98755573b1d8a69acd1f4e2639fa6b">operator=</a> (is_just_volatile_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a5f98755573b1d8a69acd1f4e2639fa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed68aa5cb46c6c06a171a43f452fda0c"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aed68aa5cb46c6c06a171a43f452fda0c">operator=</a> (is_just_volatile_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> &gt; auto &amp;&amp;other) volatile noexcept</td></tr>
<tr class="separator:aed68aa5cb46c6c06a171a43f452fda0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1a91d3423e6653b8983a1e750a32a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a9f1a91d3423e6653b8983a1e750a32a4">~heap_t</a> ()=default</td></tr>
<tr class="separator:a9f1a91d3423e6653b8983a1e750a32a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpa9ac5a6cc3cbe84f9c18323af2b9007f"></a></p>
</td></tr>
<tr class="memitem:a4dea6283a09029b9c85892dd1ff24218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a4dea6283a09029b9c85892dd1ff24218">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count) const</td></tr>
<tr class="memdesc:a4dea6283a09029b9c85892dd1ff24218"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a4dea6283a09029b9c85892dd1ff24218">More...</a><br /></td></tr>
<tr class="separator:a4dea6283a09029b9c85892dd1ff24218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778f2bee6d0959f87149e96e6806f59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a2778f2bee6d0959f87149e96e6806f59">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count) const volatile</td></tr>
<tr class="memdesc:a2778f2bee6d0959f87149e96e6806f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a2778f2bee6d0959f87149e96e6806f59">More...</a><br /></td></tr>
<tr class="separator:a2778f2bee6d0959f87149e96e6806f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d663a87ea939c03b67adaa998b9d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a60d663a87ea939c03b67adaa998b9d5d">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count) const</td></tr>
<tr class="memdesc:a60d663a87ea939c03b67adaa998b9d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a60d663a87ea939c03b67adaa998b9d5d">More...</a><br /></td></tr>
<tr class="separator:a60d663a87ea939c03b67adaa998b9d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d6c43f2755c218091b7f0aa60f3f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a48d6c43f2755c218091b7f0aa60f3f1f">Allocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> unit_count) const volatile</td></tr>
<tr class="memdesc:a48d6c43f2755c218091b7f0aa60f3f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a48d6c43f2755c218091b7f0aa60f3f1f">More...</a><br /></td></tr>
<tr class="separator:a48d6c43f2755c218091b7f0aa60f3f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c77fe6d4d5c50f18540e44fe88dd064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a8c77fe6d4d5c50f18540e44fe88dd064">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count) const</td></tr>
<tr class="memdesc:a8c77fe6d4d5c50f18540e44fe88dd064"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a8c77fe6d4d5c50f18540e44fe88dd064">More...</a><br /></td></tr>
<tr class="separator:a8c77fe6d4d5c50f18540e44fe88dd064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa580a5b9af98bdb7d75b310e9b727e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaa580a5b9af98bdb7d75b310e9b727e5">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count) const volatile</td></tr>
<tr class="memdesc:aaa580a5b9af98bdb7d75b310e9b727e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#aaa580a5b9af98bdb7d75b310e9b727e5">More...</a><br /></td></tr>
<tr class="separator:aaa580a5b9af98bdb7d75b310e9b727e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268a87a0e195d6fef52c0257b76e1aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a268a87a0e195d6fef52c0257b76e1aa9">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count) const</td></tr>
<tr class="memdesc:a268a87a0e195d6fef52c0257b76e1aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a268a87a0e195d6fef52c0257b76e1aa9">More...</a><br /></td></tr>
<tr class="separator:a268a87a0e195d6fef52c0257b76e1aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db378e8ef1139336c613782c6726193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a4db378e8ef1139336c613782c6726193">Reallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units, <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> new_unit_count) const volatile</td></tr>
<tr class="memdesc:a4db378e8ef1139336c613782c6726193"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but t can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a4db378e8ef1139336c613782c6726193">More...</a><br /></td></tr>
<tr class="separator:a4db378e8ef1139336c613782c6726193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34766fe49b9b672b74d92dadc0dc36f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a34766fe49b9b672b74d92dadc0dc36f0">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units) const</td></tr>
<tr class="memdesc:a34766fe49b9b672b74d92dadc0dc36f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a34766fe49b9b672b74d92dadc0dc36f0">More...</a><br /></td></tr>
<tr class="separator:a34766fe49b9b672b74d92dadc0dc36f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b9b7704286d2d5a2c7959c8a1f864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#ad62b9b7704286d2d5a2c7959c8a1f864">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;units) const volatile</td></tr>
<tr class="memdesc:ad62b9b7704286d2d5a2c7959c8a1f864"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#ad62b9b7704286d2d5a2c7959c8a1f864">More...</a><br /></td></tr>
<tr class="separator:ad62b9b7704286d2d5a2c7959c8a1f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0a01454d652fe3e82363bf344bd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#adbf0a01454d652fe3e82363bf344bd0d">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units) const</td></tr>
<tr class="memdesc:adbf0a01454d652fe3e82363bf344bd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#adbf0a01454d652fe3e82363bf344bd0d">More...</a><br /></td></tr>
<tr class="separator:adbf0a01454d652fe3e82363bf344bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750bafa3d38653b02e0a7e4b6f29915a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a750bafa3d38653b02e0a7e4b6f29915a">Deallocate</a> (is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;units) const volatile</td></tr>
<tr class="memdesc:a750bafa3d38653b02e0a7e4b6f29915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>.  <a href="classnkr_1_1allocator_1_1heap__t.html#a750bafa3d38653b02e0a7e4b6f29915a">More...</a><br /></td></tr>
<tr class="separator:a750bafa3d38653b02e0a7e4b6f29915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;any_type_tr unit_p&gt;<br />
class nkr::allocator::heap_t&lt; unit_p &gt;</div><p >A wrapper for the <a class="el" href="namespacenkr_1_1os_1_1heap.html" title="Functions that interface with memory located on the heap. Primarily, this is an extension of the stan...">nkr::os::heap</a> allocator, often used by other types around the library as the default allocator. </p>
<p >In addition to working directly with C pointers, in order to satisfy the nkr::allocator_i this also handles <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a> objects, correctly setting their unit counts after operating upon them. The primary purpose of this type and others like it is to provide an interchangable set of allocators with which to use with other types around the library, for example nkr::array::dynamic_t. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5c30b02946b76ad8f35b800510ca8358" name="a5c30b02946b76ad8f35b800510ca8358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c30b02946b76ad8f35b800510ca8358">&#9670;&nbsp;</a></span>unit_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a5c30b02946b76ad8f35b800510ca8358">unit_t</a> =  unit_p</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying type which space will be allocated for. </p>

</div>
</div>
<a id="aaf8d87d62b8d22b78e06211a5db68178" name="aaf8d87d62b8d22b78e06211a5db68178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d87d62b8d22b78e06211a5db68178">&#9670;&nbsp;</a></span>units_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> =  unit_p*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard C pointer of unit_t which works with this allocator. </p>

</div>
</div>
<a id="a3ed2dcc75aaf1f828b639e74b684bece" name="a3ed2dcc75aaf1f828b639e74b684bece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2dcc75aaf1f828b639e74b684bece">&#9670;&nbsp;</a></span>pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> =  <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a>&lt;unit_p&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">pointer_t</a> which works with this allocator. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a931f6bd0663a5452688b15081e65edff" name="a931f6bd0663a5452688b15081e65edff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931f6bd0663a5452688b15081e65edff">&#9670;&nbsp;</a></span>heap_t() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ac5a1093199a2cfef563309491cb5e18d" name="ac5a1093199a2cfef563309491cb5e18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a1093199a2cfef563309491cb5e18d">&#9670;&nbsp;</a></span>heap_t() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a96180f4b14b62792b6fa50d9bfe1a185" name="a96180f4b14b62792b6fa50d9bfe1a185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96180f4b14b62792b6fa50d9bfe1a185">&#9670;&nbsp;</a></span>heap_t() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="aff9939b6a738a297d92de0675aa7bf6c" name="aff9939b6a738a297d92de0675aa7bf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9939b6a738a297d92de0675aa7bf6c">&#9670;&nbsp;</a></span>heap_t() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a4b0303b3bdd4805989f73a755e72202f" name="a4b0303b3bdd4805989f73a755e72202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0303b3bdd4805989f73a755e72202f">&#9670;&nbsp;</a></span>heap_t() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a9f1a91d3423e6653b8983a1e750a32a4" name="a9f1a91d3423e6653b8983a1e750a32a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1a91d3423e6653b8983a1e750a32a4">&#9670;&nbsp;</a></span>~heap_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::~<a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a52e688b3bdafbc14968d98df8a8c9feb" name="a52e688b3bdafbc14968d98df8a8c9feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e688b3bdafbc14968d98df8a8c9feb">&#9670;&nbsp;</a></span>Min_Unit_Count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Min_Unit_Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not used by this particular allocator. Always equals to 0. </p>

</div>
</div>
<a id="a0c77d45a11cb4487b21a96d2aa4b6629" name="a0c77d45a11cb4487b21a96d2aa4b6629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c77d45a11cb4487b21a96d2aa4b6629">&#9670;&nbsp;</a></span>Max_Unit_Count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Max_Unit_Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the maximum number of objects which space can be allocated for. </p>
<p >This limitation exists due to the size of the word_t of the machine and the physical limits of memory address space. Very improbable to reach with a 64-bit processor but 32-bit is a different story, with limitations of just under 4 gigabytes of allocatable space. For convenience, the unit_t is the basis of the metric rather than bytes. </p>

</div>
</div>
<a id="a4c8a10a21c59285871d4e642e5a76729" name="a4c8a10a21c59285871d4e642e5a76729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a10a21c59285871d4e642e5a76729">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ab4615cbc2b80da368b0ec508d26d56f0" name="ab4615cbc2b80da368b0ec508d26d56f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4615cbc2b80da368b0ec508d26d56f0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a0b6ae27be87aebc8543e3135ebc79e5e" name="a0b6ae27be87aebc8543e3135ebc79e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6ae27be87aebc8543e3135ebc79e5e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="affe8a0a10b0c74d9b76ba91e399d58c3" name="affe8a0a10b0c74d9b76ba91e399d58c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe8a0a10b0c74d9b76ba91e399d58c3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a221db75d1fc3fabe90062fcb50f9db22" name="a221db75d1fc3fabe90062fcb50f9db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221db75d1fc3fabe90062fcb50f9db22">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a8790dba58d376ee2534a26dedb582507" name="a8790dba58d376ee2534a26dedb582507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8790dba58d376ee2534a26dedb582507">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a5f98755573b1d8a69acd1f4e2639fa6b" name="a5f98755573b1d8a69acd1f4e2639fa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f98755573b1d8a69acd1f4e2639fa6b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">is_just_volatile_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section note"><dt>Note</dt><dd>This uses a templated assignment operator in order to avoid an overload resolution conflict with the move unqualified assignment operator. This allows you to assign either a volatile or an unqualified object of this type without any issue.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>

</div>
</div>
<a id="aed68aa5cb46c6c06a171a43f452fda0c" name="aed68aa5cb46c6c06a171a43f452fda0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed68aa5cb46c6c06a171a43f452fda0c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &amp; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">is_just_volatile_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section note"><dt>Note</dt><dd>This uses a templated assignment operator in order to avoid an overload resolution conflict with the move unqualified assignment operator. This allows you to assign either a volatile or an unqualified object of this type without any issue.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>

</div>
</div>
<a id="a4dea6283a09029b9c85892dd1ff24218" name="a4dea6283a09029b9c85892dd1ff24218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dea6283a09029b9c85892dd1ff24218">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write a new address to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html" title="A tag used to assign &#39;nothing&#39; to a user-defined type, or to compare it with &#39;nothing&#39;.">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a2778f2bee6d0959f87149e96e6806f59" name="a2778f2bee6d0959f87149e96e6806f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2778f2bee6d0959f87149e96e6806f59">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const pointer that this function can write a new address to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html" title="A tag used to assign &#39;nothing&#39; to a user-defined type, or to compare it with &#39;nothing&#39;.">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a60d663a87ea939c03b67adaa998b9d5d" name="a60d663a87ea939c03b67adaa998b9d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d663a87ea939c03b67adaa998b9d5d">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a> that this function can write a new address and unit count to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html" title="A tag used to assign &#39;nothing&#39; to a user-defined type, or to compare it with &#39;nothing&#39;.">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a48d6c43f2755c218091b7f0aa60f3f1f" name="a48d6c43f2755c218091b7f0aa60f3f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d6c43f2755c218091b7f0aa60f3f1f">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>should be a non const <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a> that this function can write a new address and unit count to. The qualification of the unit_t itself does not matter. Must be equal to <a class="el" href="classnkr_1_1none__t.html" title="A tag used to assign &#39;nothing&#39; to a user-defined type, or to compare it with &#39;nothing&#39;.">none_t</a> or it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
    <tr><td class="paramname">unit_count</td><td>is the number of unit_t objects for which to allocate space. If this number is more than <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a0c77d45a11cb4487b21a96d2aa4b6629" title="This is the maximum number of objects which space can be allocated for.">nkr::allocator::heap_t::Max_Unit_Count</a>, it will assert. See <a class="el" href="namespacenkr_1_1os_1_1heap.html#a3aa3054fcc1b5577c0bcfd8f81c8f3e4" title="Gives you memory to use until you deallocate it or your program exits.">nkr::os::heap::Allocate</a> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a moved nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
a moved nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a8c77fe6d4d5c50f18540e44fe88dd064" name="a8c77fe6d4d5c50f18540e44fe88dd064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c77fe6d4d5c50f18540e44fe88dd064">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="aaa580a5b9af98bdb7d75b310e9b727e5" name="aaa580a5b9af98bdb7d75b310e9b727e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa580a5b9af98bdb7d75b310e9b727e5">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a268a87a0e195d6fef52c0257b76e1aa9" name="a268a87a0e195d6fef52c0257b76e1aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268a87a0e195d6fef52c0257b76e1aa9">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a4db378e8ef1139336c613782c6726193" name="a4db378e8ef1139336c613782c6726193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db378e8ef1139336c613782c6726193">&#9670;&nbsp;</a></span>Reallocate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1maybe__t.html">maybe_t</a>&lt; allocator_err &gt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Reallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__intrinsics__contextuals.html#ga962bdb5ad1c5bc05d87739e09df6082b">count_t</a>&#160;</td>
          <td class="paramname"><em>new_unit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#a52065c5bdf7e1f414f00b31e7e671be9" title="Gives you more memory without loosing any of the previously allocated memory.">nkr::os::heap::Reallocate</a>, but t can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nkr::allocator_err::NONE if it succeeds.</dd>
<dd>
nkr::allocator_err::OUT_OF_MEMORY if it fails. </dd></dl>

</div>
</div>
<a id="a34766fe49b9b672b74d92dadc0dc36f0" name="a34766fe49b9b672b74d92dadc0dc36f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34766fe49b9b672b74d92dadc0dc36f0">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>. </p>

</div>
</div>
<a id="ad62b9b7704286d2d5a2c7959c8a1f864" name="ad62b9b7704286d2d5a2c7959c8a1f864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62b9b7704286d2d5a2c7959c8a1f864">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#aaf8d87d62b8d22b78e06211a5db68178">units_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>. </p>

</div>
</div>
<a id="adbf0a01454d652fe3e82363bf344bd0d" name="adbf0a01454d652fe3e82363bf344bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0a01454d652fe3e82363bf344bd0d">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>

</div>
</div>
<a id="a750bafa3d38653b02e0a7e4b6f29915a" name="a750bafa3d38653b02e0a7e4b6f29915a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750bafa3d38653b02e0a7e4b6f29915a">&#9670;&nbsp;</a></span>Deallocate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__intrinsics__primitives.html#ga034482d2e50c6d0448a7953d24860fe9">void_t</a> <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">nkr::allocator::heap_t</a>&lt; unit_p &gt;::Deallocate </td>
          <td>(</td>
          <td class="paramtype">is_any_non_const_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html#a3ed2dcc75aaf1f828b639e74b684bece">pointer_t</a> &gt; auto &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper for <a class="el" href="namespacenkr_1_1os_1_1heap.html#ad27c431dc437f08ed8e3ad901ea31ba3" title="Takes back memory you no longer need so it can be reused later.">nkr::os::heap::Deallocate</a>, but it can handle a <a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer and the number of units that the pointer points to.">nkr::pointer_t</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1aae4bf469928b2883177e7ceba11ed8" name="a1aae4bf469928b2883177e7ceba11ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aae4bf469928b2883177e7ceba11ed8">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a> operator== </td>
          <td>(</td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares any qualified or unqualifed version of the type. </p>

</div>
</div>
<a id="affe9d3d9505148cd1ae4daefddf84c8b" name="affe9d3d9505148cd1ae4daefddf84c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe9d3d9505148cd1ae4daefddf84c8b">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;any_type_tr unit_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnkr_1_1bool__t.html">bool_t</a> operator!= </td>
          <td>(</td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">is_any_tr&lt; <a class="el" href="classnkr_1_1allocator_1_1heap__t.html">heap_t</a>&lt; unit_p &gt; &gt; auto&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares any qualified or unqualifed version of the type. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
