<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">My C++20 library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="mainpage"></a></p>
<h2><a class="anchor" id="autotoc_md0"></a>
General-Use Types</h2>
<p ><code>nkr</code> exists to provide an assortment of well-rounded generic <code>types</code> offering fleshed-out functionality and interoperation through two primary meta-programming abstractions: <code>traits</code> and <code>interfaces</code>:</p><ul>
<li><code>traits</code> are concepts that essentially act as the nouns for types and are divided into two general sub-categories:<ul>
<li><code>identities</code><ul>
<li>these constrain to any instantiation of a particular template type or to a non-template type. In either case, they may be const, volatile, const volatile, or non-qualified. If the type is a template, a sibling identity exists to constrain the template itself, making the template a first class citizen in the library.</li>
</ul>
</li>
<li><code>generics</code><ul>
<li>these constrain to multiple <code>identities</code> and are also hierarchically allowed to constrain to other <code>generics</code>. They are used to describe groups of <code>identities</code> both in a meaningful and a practical way. For example a <code>generic</code> may constrain to any array, or perhaps to any array that stores its data locally, or alternatively, to any array that stores its data remotely. Any <code>identity</code> that satisfies these <code>generics</code> necessarily satisfies their requirements, and in this case that would include the access operator. In this way, templated code may reliably work with any of these constrained arrays by accessing their elements.</li>
</ul>
</li>
</ul>
</li>
<li><code>interfaces</code> are concepts that essentially act as verbs for <code>types</code> and <code>traits</code> by specifying how they may do something. They describe not what a type is, but what it can do. A great example of an interface is for the <code>nkr::none::value_t</code>. Whereas a <code>trait</code> may require that a type have a default constructor to provide a value that may or may not be equal to <code>none</code>, an <code>interface</code> only requires a soft-coupling to define what the <code>none</code> value is for a particular <code>identity</code>, whether it is has a default constructor or not, or if it does but the default value is not equal to <code>none</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Full Qualifications</h2>
<p >As much as possible, this library provides methods available for <code>const</code>, <code>volatile</code>, and <code>const volatile</code> qualifications of types, in addition to the the standard non-qualification. The only exceptions are for when it doesn't make sense for a particular type to have a certain qualification, or if we are currently using a C++ type in some way, which often does not define <code>const</code> and <code>volatile</code> qualifications.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Design</h1>
<h3><a class="anchor" id="autotoc_md3"></a>
Data Labels</h3>
<p >There are a number of postfixes tacked unto labels to differentiate them from various kinds of syntactic data. For example, "example_t" is for "example type", "example_i" for "example interface", "example_tr" for "example trait", "example_tg" for "example tag", just to name a few. This helps to secure an open namespace for new labels to be added in the future, even if they are in the same namespace and have the same base name.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
File Hierarchy</h3>
<p >Files mimic the hierarchy of the library's namespaces and include the postfix of whatever it is they are primarily declaring or defining. For example, types have "_t" in the name of the file, such as in "example_t", and interfaces have "_i" in the name of the file, such as in "example_i". This gives as much room to avoid collisions as there is in the general namespace and leaves open more general files such as "example" where they are needed. In addition, post-postfixes are added to files that make them distinct based on their function in the include system. For example, "example_t_dec.h" is for "example_t declaration" and "example_t_def.h" for "example_t definition". Additionally, there is a primary header for each group of sub-headers that does not include a post-postfix. This file allows for a consumer of the library to easily pull in everything they need for that entity, with every file already included in order.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Equality Operators are Globals</h3>
<p >For the sake of compatibility and control we define equality operators for types using a specific and exhaustive pattern all in the top global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
</div><!-- fragment --><p >Because the left hand parameter is a templated type, it prevents a potentially confusing new feature of C++20 that automatically tries reversing arguments for standard operators, which can lead to a lot of compatibility issues and ambiguities with other types defining equality operators. Notice that the b parameter is always const, even for rvalue references. This gives an extreme amount of flexibility while maintaining as much clarity as possible. Notice also that we define no reverse versions of these operators. This allows us to define these same set of functions per type and to give them proper definitions where applicable, all without causing collisions and ambiguities. We make up for any lack of reverse definitions by allowing any type whatsoever to attempt comparison in the general algorithm below:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> nkr::tr1&lt;nkr::any_tg, nkr::example_t&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> a_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> b_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::is_any_tr&lt;b_t, a_t&gt;) {</div>
<div class="line">        <span class="comment">// works with any qualified version of the same type by comparing their inner values.</span></div>
<div class="line">        <span class="keywordflow">return</span> a() == b();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// only applicable if a_t has an inner type, in this case value_t. there can be any number of these specific to this type.</span></div>
<div class="line">        <span class="keywordflow">return</span> a() == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;a_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// tries to convert b_t to a_t and recurses back to this operator.</span></div>
<div class="line">        <span class="keywordflow">return</span> a == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;a_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;a_t, nkr::cpp::just_non_qualified_t&lt;b_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// tries to convert a_t to b_t and compares with b&#39;s algorithm.</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;b_t&gt;<span class="keyword">&gt;</span>(a) == b;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;these two values can not be compared.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >This is the only equality operator in the group of declarations above that has such a definition, as the rest simply convert their arguments and/or complement their logic to call this one.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Move Assignment of Volatile Types</h3>
<p >In order to avoid an overload resolution ambiguity, we often use a templated operator to define the move assignment of volatile types. Because templates have a lower precedence than normal operators, this allows for both volatile and non-volatile instances as well as new constructions of the type to be move-assigned properly, and also allows other types that can be converted through a constructor of the type to be properly assigned as expected.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>example_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    example_t&amp;            operator =(<span class="keyword">const</span> example_t&amp; other);</div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp;   operator =(<span class="keyword">const</span> example_t&amp; other) <span class="keyword">volatile</span>;</div>
<div class="line">    example_t&amp;            operator =(<span class="keyword">const</span> <span class="keyword">volatile</span> example_t&amp; other);</div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp;   operator =(<span class="keyword">const</span> <span class="keyword">volatile</span> example_t&amp; other) <span class="keyword">volatile</span>;</div>
<div class="line">    example_t&amp;            operator =(example_t&amp;&amp; other);                                        <span class="comment">// may match any rvalue that is or can be converted implicitly to an example_t</span></div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp;   operator =(example_t&amp;&amp; other) <span class="keyword">volatile</span>;                               <span class="comment">// &quot;&quot;</span></div>
<div class="line">    example_t&amp;            operator =(tr1&lt;just_volatile_tg, example_t&gt; <span class="keyword">auto</span>&amp;&amp; other);            <span class="comment">// only ever resolves if given a volatile example_t&amp;&amp;</span></div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp;   operator =(tr1&lt;just_volatile_tg, example_t&gt; <span class="keyword">auto</span>&amp;&amp; other) <span class="keyword">volatile</span>;   <span class="comment">// &quot;&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="_16d56f49_95ba_456e_a026_706c054cb133"></a>
Partial Specializations By Concept</h3>
<p >Because we are using C++20 concepts, we have to work around a bug that exists in two of the major compilers. In order to use out-of-body class definitions, we take advantage of a pattern of concept partial specialization which indirectly maps onto separate types. An alias of this indirection is used as the primary type. The actual types that make up the specializations should be put in a non-colliding namespace one step interior to the namespace where the primary type lives. No members in the indirection template may be defined out-of-body:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> { <span class="keyword">namespace </span>$example_t {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>eger_tr value_p&gt;</div>
<div class="line">    <span class="keyword">class </span>integer_sp</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// has any member you want, and they can all be defined out-of-body</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;po<span class="keywordtype">int</span>er_tr value_p&gt;</div>
<div class="line">    <span class="keyword">class </span>pointer_sp</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// &quot;&quot;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_p&gt;</div>
<div class="line">    <span class="keyword">class </span>example_t_sp;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>eger_tr value_p&gt;</div>
<div class="line">    <span class="keyword">class </span>example_t_sp</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> type_t    = $example_t::integer_sp&lt;value_p&gt;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;po<span class="keywordtype">int</span>er_tr value_p&gt;</div>
<div class="line">    <span class="keyword">class </span>example_t_sp</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> type_t    = $example_t::pointer_sp&lt;value_p&gt;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_p&gt;</div>
<div class="line">    <span class="keyword">using</span> example_t = example_t_sp&lt;value_p&gt;::type_t;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="anamespacenkr_html"><div class="ttname"><a href="namespacenkr.html">nkr</a></div><div class="ttdoc">With the exception of &quot;nkr_&quot; prefixed macros, all other nkr entities are defined in this namespace.</div><div class="ttdef"><b>Definition:</b> array/cpp_t_dec.h:14</div></div>
</div><!-- fragment --><p> <a href="https://github.com/r-neal-kelly/the_concept_bug">View a small but detailed example of this bug.</a></p>
<p ><a href="https://stackoverflow.com/questions/68589314/how-to-define-a-specialized-class-method-outside-of-class-body-in-c">Read about it on stackoverflow.</a></p>
<h2><a class="anchor" id="autotoc_md7"></a>
Documentation Status</h2>
<p >We are in the pre-alpha phase of the library. We are currently prototyping and designing the overarching system of types, traits, and interfaces, and importantly, we are designing the documentation itself. Currently we are implementing the third iteration of traits and interfaces across the library which in addition to improving accessibility and performance, also addresses a consistency issue with the previous two iterations. In the meantime, the documentation remains focused on the old versions, but after we finish this latest iteration we will be updating this documentation to not only reflect the new types as well as the old, but also to give particular focus to the new traits and interfaces that describe the system as a whole. Until that time, anything following in the documentation refers to code that has either been moved or is in the process of being moved to the new system. Thank you for your understanding.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
Basics</h4>
<ul>
<li><a class="el" href="classnkr_1_1bool__t.html" title="The default boolean type of this library which replaces nkr::c_bool_t.">nkr::bool_t</a></li>
<li><a class="el" href="classnkr_1_1pointer__t.html" title="A fat pointer that stores a pointer to any unit_t and a unit count indicating the size of memory bein...">nkr::pointer_t</a></li>
<li><a class="el" href="classnkr_1_1atomic__t.html" title="The default template for nkr::atomic_t, which invalidates types not matching any specialization.">nkr::atomic_t</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md9"></a>
Maybes</h4>
<ul>
<li><a class="el" href="conceptnkr_1_1none__i.html" title="Allows any user-defined type to interact with nkr::none_t, which is necessary for nkr::maybe_t and nk...">nkr::none_i</a></li>
<li><a class="el" href="classnkr_1_1none__t.html" title="A tag used to assign &#39;nothing&#39; to a user-defined type, or to compare it with &#39;nothing&#39;.">nkr::none_t</a></li>
<li><a class="el" href="conceptnkr_1_1maybe__i.html">nkr::maybe_i</a></li>
<li><a class="el" href="classnkr_1_1maybe__t.html" title="Wraps a type whose object may have a value.">nkr::maybe_t</a></li>
<li><a class="el" href="conceptnkr_1_1some__i.html">nkr::some_i</a></li>
<li><a class="el" href="classnkr_1_1some__t.html" title="Wraps a type whose object has some value.">nkr::some_t</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md10"></a>
Allocators</h4>
<ul>
<li><a class="el" href="conceptnkr_1_1allocator__i.html" title="Defines common functionality that must exist on an allocator implementation for use in nkr.">nkr::allocator_i</a></li>
<li><a class="el" href="classnkr_1_1allocator_1_1heap__t.html" title="A wrapper for the nkr::os::heap allocator, often used by other types around the library as their defa...">nkr::allocator::heap_t</a></li>
<li><a class="el" href="classnkr_1_1allocator_1_1heap__zeros__t.html" title="A wrapper for the nkr::os::heap allocator similar to nkr::allocator::heap_t except that it additional...">nkr::allocator::heap_zeros_t</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md11"></a>
Arrays</h4>
<ul>
<li>nkr::array_i</li>
<li>nkr::array::dynamic_t</li>
<li>nkr::array::instant_t</li>
<li>nkr::array::stack_t</li>
</ul>
<h4><a class="anchor" id="autotoc_md12"></a>
Charcoders</h4>
<ul>
<li>nkr::charcoder_i</li>
<li>nkr::charcoder::ascii_t</li>
<li>nkr::charcoder::utf_8_t</li>
<li>nkr::charcoder::utf_16_t</li>
<li>nkr::charcoder::utf_32_t</li>
</ul>
<h4><a class="anchor" id="autotoc_md13"></a>
Enumerations</h4>
<ul>
<li>nkr::enumeration::flags_t</li>
<li>nkr::enumeration::types_t</li>
<li>nkr::enumeration::errors_t</li>
</ul>
<h4><a class="anchor" id="autotoc_md14"></a>
Numbers</h4>
<ul>
<li>nkr::signed_negative_t</li>
<li>nkr::signed_positive_t</li>
</ul>
<h4><a class="anchor" id="autotoc_md15"></a>
Strings</h4>
<ul>
<li>nkr::string::dynamic_t</li>
<li>nkr::string::static_t</li>
</ul>
<h4><a class="anchor" id="autotoc_md16"></a>
Namespaced Functions</h4>
<ul>
<li>nkr::math</li>
<li><a class="el" href="namespacenkr_1_1os.html" title="Short for &quot;Operating System&quot;, this contains several wrappers for otherwise platform specific function...">nkr::os</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md17"></a>
Global nkr Definitions</h4>
<ul>
<li>fors.h</li>
<li>intrinsics.h</li>
<li>macros.h</li>
<li>traits.h</li>
<li>utils.h </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
