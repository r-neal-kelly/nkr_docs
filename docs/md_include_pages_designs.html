<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Designs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Designs </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#_2cc5247e_75fb_4baa_91b3_b1be6ba6faff">Exception Avoidance</a></li>
<li class="level1"><a href="#_1f10466e_b496_498a_a930_6c7227b37371">Global Equality Operators</a></li>
<li class="level1"><a href="#_749bceb9_9b02_4278_bd34_a8a83933e675">Identities</a></li>
<li class="level1"><a href="#_3199146d_6573_4ada_8636_0e3a2607116a">Interface Specialization Indirection</a></li>
<li class="level1"><a href="#_839025a7_339e_4e65_a259_5feacb45ea12">Label Postfixes</a><ul><li class="level2"><a href="#_1382824d_0c2f_476c_b433_cf542fd6bdef">List of Label Postfixes</a></li>
</ul>
</li>
<li class="level1"><a href="#_d720707b_2ea9_49b9_8625_8bca5b680359">Move Assignment of Volatile Instances</a></li>
<li class="level1"><a href="#_fb50a132_1997_4cb6_92b0_616254f27bae">One Hierarchy</a></li>
<li class="level1"><a href="#_ab449a60_e674_4d0a_91d9_557ec4c5660c">One Kind of Template Parameter</a></li>
<li class="level1"><a href="#_8f6a1988_bbdb_46ba_8746_40c02acda41c">Primary Inner Type</a></li>
<li class="level1"><a href="#_94c723c3_0213_4866_a383_50edc6ef02bd">Primary Inner Value</a></li>
<li class="level1"><a href="#_a742d628_4b70_448e_bdc4_594f6954bdb2">Qualification Support</a></li>
<li class="level1"><a href="#_5451462d_8ed6_4fc2_86f0_b2f98e5efdc6">Type Documentation</a></li>
<li class="level1"><a href="#_5a685522_8b24_41da_83f3_03603bf8965c">Type Sections</a></li>
</ul>
</div>
<div class="textblock"><p >Many key concepts concerning design exist in <a class="el" href="namespacenkr.html">nkr</a>, and their presence is felt all throughout the library. Their purposes involve the goals of memorization, scalability, performance, readability, and more. This page exists to argue the case for each design decision, to show how to take advantage of each pattern, and importantly, how to maintain that pattern when adding to the library.</p>
<p >Every single one of these designs has a non-trivial purpose and a lot of research and prototyping to back them up. A voluminous number of code examples exist per design and should be taken full advantage of in order to grasp why and how each pattern exists to specifically benefit you and your end-users. Every single piece of code is sampled from various test suites and thus is always up-to-date. Due to the length of these code examples, a table of contents located to your right is available for your convenience.</p>
<h1><a class="anchor" id="_2cc5247e_75fb_4baa_91b3_b1be6ba6faff"></a>
Exception Avoidance</h1>
<p >(W.I.P)</p>
<hr  />
<h1><a class="anchor" id="_1f10466e_b496_498a_a930_6c7227b37371"></a>
Global Equality Operators</h1>
<p >We define equality operators outside of the <a class="el" href="namespacenkr.html">nkr</a> namespace and in the global scope. We follow a <b>very specific pattern</b>. For <code>constexpr</code> types we write:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>constexpr_t;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="ttc" id="aconceptnkr_1_1tr_html"><div class="ttname"><a href="conceptnkr_1_1tr.html">nkr::tr</a></div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div><div class="ttdef"><b>Definition:</b> tr_dec.h:261</div></div>
<div class="ttc" id="anamespacenkr_html"><div class="ttname"><a href="namespacenkr.html">nkr</a></div><div class="ttdoc">The entire library is contained within this namespace.</div><div class="ttdef"><b>Definition:</b> array/cpp_t_dec.h:14</div></div>
<div class="ttc" id="anamespacenkr_html_aecb8f05af8f5d93778ce60239336d8e3"><div class="ttname"><a href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t</a></div><div class="ttdeci">nkr::tr$::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:175</div></div>
</div><!-- fragment --><p >And for non-<code>constexpr</code> constructible types we merely drop the <code>constexpr</code> at the beginning of the declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>non_constexpr_t;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
</div><!-- fragment --><p >Following the above pattern makes all equality operator overloads <b>templates</b>, and with that point in mind, this pattern avoids two very important conflicts:</p><ol type="1">
<li>Because the first template parameter, and <em>only</em> the first template parameter is constrained specifically to an <code>identity</code> and never a <code>generic</code>, <b>this pattern can <em>never</em> have ambiguous operator overload collisions with other operators that follow the same exact pattern</b>. This allows us to extend this pattern to all types ad infinitum, including types that inherit base types with their own overloads defined or types that can otherwise implicitly be converted to another.</li>
<li>Because all possible values are covered in the second parameter, including both lvalues and rvalues of any type whatsoever, <b>it is <em>impossible</em> for operator overload resolution to resolve to any implicit conversions from the second type</b>, in particular during reverse operator resolution - a potentially frustrating addition to the C++20 standard.</li>
</ol>
<p >Following this pattern gives an extreme amount of flexibility for users. A user need not worry about the order of their arguments and whether including this or that file will somehow cause the compiler to spit out a thousand-line-long error message, resulting in a headache for the user every time it happens.</p>
<p >However, this comes at the cost of extra development effort. Every single type must define their own operator overloads explicitly. This means if you wish to use the overload of another type, you must define its operators and explicitly cast to that type. For this reason, the pattern was designed such that you only need to define one of the eight operators, and the rest can be easily defined as proxies.</p>
<p >The following is a full example of how one would define the operators for two different types, neither of which knows if the other is compatible. Both of them have an identifiable <a class="el" href="md_include_pages_designs.html#_8f6a1988_bbdb_46ba_8746_40c02acda41c">primary inner type</a>, which adds options to their algorithms that otherwise might not be there:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>equality_a_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// The primary inner type.</span></div>
<div class="line">        <span class="keyword">using</span> value_t   = long;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        value_t value;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> equality_a_t(value_t value) noexcept :</div>
<div class="line">            value(value)</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>equality_b_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// The primary inner type. It&#39;s different from equality_a_t&#39;s.</span></div>
<div class="line">        <span class="keyword">using</span> value_t   = <span class="keywordtype">long</span> long;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        value_t value;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> equality_b_t(value_t value) noexcept :</div>
<div class="line">            value(value)</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notice that we can construct this type with equality_a_t.</span></div>
<div class="line">        <span class="keyword">constexpr</span> equality_b_t(equality_a_t value) noexcept :</div>
<div class="line">            value(value.value)</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward declare equality_a_t&#39;s ops so it can see equality_b_t&#39;s ops.</span></div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// And vice versa.</span></div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"><span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Here we define equality_a_t&#39;s operators.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We want the value_t and not a value_t&amp; type.</span></div>
<div class="line">    <span class="keyword">using</span> a_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> b_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::is_any_tr&lt;b_t, a_t&gt;) {</div>
<div class="line">        <span class="comment">// If b_t is equality_a_t, it&#39;s super easy to compare the two.</span></div>
<div class="line">        <span class="keywordflow">return</span> a.value == b.value;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// If b_t is equality_b_t, then this won&#39;t be branched to because it doesn&#39;t have a cast to</span></div>
<div class="line">        <span class="comment">// value_t operator. However another type might, and because our type defines equality based on</span></div>
<div class="line">        <span class="comment">// its primary inner type, it makes sense to have this branch. However if our type doesn&#39;t have</span></div>
<div class="line">        <span class="comment">// a primary inner type, it maybe should be excluded. This technique relies on a good design of</span></div>
<div class="line">        <span class="comment">// b_t, which should be castable to other types only when it&#39;s meaningful.</span></div>
<div class="line">        <span class="keywordflow">return</span> a.value == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;a_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// If b_t is equality_b_t, then this won&#39;t be branched to because a_t cannot be constructed from</span></div>
<div class="line">        <span class="comment">// an equality_b_t, nor can equality_b_t be cast to a_t. Notice that this recursively calls this</span></div>
<div class="line">        <span class="comment">// operator, we don&#39;t need to define a_t == a_t twice!</span></div>
<div class="line">        <span class="keywordflow">return</span> a == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;a_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;a_t, nkr::cpp::just_non_qualified_t&lt;b_t&gt;&gt;) {</div>
<div class="line">        <span class="comment">// If b_t is equality_b_t, then even though equality_a_t cannot be cast to equality_b_t,</span></div>
<div class="line">        <span class="comment">// equality_b_t can be constructed with equality_a_t, so this is the branch that will compile.</span></div>
<div class="line">        <span class="comment">// However take note that equality_b_t&#39;s operators must be defined!</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;b_t&gt;<span class="keyword">&gt;</span>(a) == b;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Bail, because there&#39;s no defined way to compare these two types. Make sure to let the user</span></div>
<div class="line">        <span class="comment">// know what happend. As complicated as it is, this standards compliant technique works great:</span></div>
<div class="line">        [] &lt;nkr::boolean::cpp_t _ = <span class="keyword">false</span>&gt;() { <span class="keyword">static_assert</span>(_, <span class="stringliteral">&quot;these two values can not be compared.&quot;</span>); }();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The rest of these just call the above operator.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Here we do the same thing as above, but for equality_b_t.</span></div>
<div class="line"><span class="comment">// We have the same algorithm because the two types are similar, but other types may have different algorithms.</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> a_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(a)&gt;;</div>
<div class="line">    <span class="keyword">using</span> b_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(b)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::is_any_tr&lt;b_t, a_t&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> a.value == b.value;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> a.value == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;a_t&gt;&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> a == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;a_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;a_t, nkr::cpp::just_non_qualified_t&lt;b_t&gt;&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;b_t&gt;<span class="keyword">&gt;</span>(a) == b;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        [] &lt;nkr::boolean::cpp_t _ = <span class="keyword">false</span>&gt;() { <span class="keyword">static_assert</span>(_, <span class="stringliteral">&quot;these two values can not be compared.&quot;</span>); }();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">    operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">    <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now we can fully equate values of these two types in every imaginable way:</p>
<div class="fragment"><div class="line"><span class="comment">// This calls equality_a_t branch 1</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::equality_a_t(1) == nkr::equality_a_t(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This calls equality_a_t branch 4 then equality_b_t branch 1</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::equality_a_t(1) == nkr::equality_b_t(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This calls equality_b_t branch 1</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::equality_b_t(1) == nkr::equality_b_t(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This calls equality_b_t branch 3 then equality_b_t branch 1</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::equality_b_t(1) == nkr::equality_a_t(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Even const and/or volatile values play nicely:</span></div>
<div class="line"><span class="keyword">const</span> nkr::equality_a_t equality_a = 1;</div>
<div class="line"><span class="keyword">volatile</span> nkr::equality_a_t equality_b = 1;</div>
<div class="line"> </div>
<div class="line">CHECK((equality_a == equality_b));</div>
<div class="line">CHECK((equality_b == equality_a));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Any combination of lvalues, rvalues, and temp values will just work:</span></div>
<div class="line">CHECK((nkr::equality_a_t(1) == equality_b));</div>
<div class="line">CHECK((equality_a == nkr::cpp::Move(equality_b)));</div>
<div class="line"> </div>
<div class="line">CHECK((nkr::equality_b_t(1) == equality_a));</div>
<div class="line">CHECK((nkr::cpp::Move(equality_b) == nkr::equality_a_t(1)));</div>
</div><!-- fragment --><p >Because all of these operators are templates, even for non-<code>constexpr</code> subjects, <code>if constexpr</code> expressions can and should be used to define the algorithms. This allows the compiler to completely optimize away most if not all the function calls that result when equating values of these and other types that have these operators.</p>
<hr  />
<h1><a class="anchor" id="_749bceb9_9b02_4278_bd34_a8a83933e675"></a>
Identities</h1>
<p ><a class="el" href="md_include_pages_glossary.html#_fd6e7324_a83c_4317_a5a8_9edfabfa7fce">Identities</a> are an integral part of the library because they provide an abstraction over functionality which necessarily needs multiple syntactical <a class="el" href="md_include_pages_glossary.html#_beac6b26_2cf9_4051_99ba_4ae5a39e66ec">entities</a> in order to be uniquely distinguished from other functionalities in the <a class="el" href="md_include_pages_glossary.html#_ef6a576b_26d1_4762_b577_3fe83cdee79f">meta-program</a>.</p>
<p >We call these distinct functionalities "identities" because each component entity that makes up an identity is integral to the identification of the <a class="el" href="md_include_pages_glossary.html#_75c3be6c_da45_4652_bf67_513fde1b9a06">primary entity</a> of interest providing the functionality, such as a <a class="el" href="md_include_pages_glossary.html#_d5fa5645_f7f9_446a_936d_459b0e0e4982">type</a>, a <a class="el" href="md_include_pages_glossary.html#_a13ace0b_d5fa_4445_87cc_c6beca57ff12">template</a>, or a <a class="el" href="md_include_pages_glossary.html#_fd358de8_6263_4f8f_b928_180781753d09">template template ad infinitum</a>.</p>
<p >In order to form an identity, we define the primary entity together with its various <a class="el" href="md_include_pages_glossary.html#_998fbcbf_ece6_455a_9f74_fda2b132fc39">identity traits</a> and <a class="el" href="md_include_pages_glossary.html#_00c037ff_572b_4949_94ba_ced07fe26487">identity tags</a>. We take advantage of the <a class="el" href="md_include_pages_designs.html#_839025a7_339e_4e65_a259_5feacb45ea12">label postfix design</a> and utilize the same <a class="el" href="md_include_pages_glossary.html#_457a439d_2c16_48e4_9163_1e21aa6b2805">base name</a> with different <a class="el" href="md_include_pages_glossary.html#_d28459df_56cd_4fe9_92a7_73c78f2f96f4">postfixes</a> to strongly signify the relation of these entities to one another.</p>
<p >We'll begin by examining the identity trait and leave the identity tag for afterwards: </p><div class="fragment"><div class="line"><span class="keyword">class </span>a_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the &quot;type indentity trait&quot; for a_t</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>a_tr =</div>
<div class="line">    nkr::cpp::is_any_tr&lt;type_p, a_t&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should constrain to any qualification of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> alias_of_a_t = a_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and naturally any qualification of an alias of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>b_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// but never any qualification of any other type</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;b_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const b_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile b_t&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile b_t&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >Here we define the identity traits of a template called "a": </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">class </span>a_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> parameters_t = nkr::tuple::types_t&lt;parameters_p...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the &quot;instantiated type indentity trait&quot; for a_t</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>a_tr =</div>
<div class="line">    nkr::cpp::is_any_tr&lt;type_p, typename type_p::parameters_t::template into_t&lt;a_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should constrain to any qualification of an instantiated a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">using</span> alias_of_a_t = a_t&lt;parameters_p...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and naturally any qualification of an instantiated alias of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">class </span>b_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> parameters_t = nkr::tuple::types_t&lt;parameters_p...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// but never any qualification of any other type</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the &quot;template indentity trait&quot; for a_t</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_p&gt;</div>
<div class="line"><span class="keyword">concept </span>a_ttr =</div>
<div class="line">    nkr::cpp::is_any_ttr&lt;template_p, a_t&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should constrain to a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_ttr&lt;a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and any alias of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_ttr&lt;alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// but never any other template</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_ttr&lt;b_t&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >And lastly we define the identity traits of a template template called "a": </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">class </span>a_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> parameters_t = nkr::tuple::templates_t&lt;parameters_p...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the &quot;instantiated type indentity trait&quot; for a_t</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>a_tr =</div>
<div class="line">    nkr::cpp::is_any_tr&lt;type_p, typename type_p::parameters_t::template into_t&lt;a_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should constrain to any qualification of an instantiated a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">using</span> alias_of_a_t = a_t&lt;parameters_p...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and naturally any qualification of an instantiated alias of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile alias_of_a_t&lt;&gt;&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...parameters_p&gt;</div>
<div class="line"><span class="keyword">class </span>b_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> parameters_t = nkr::tuple::templates_t&lt;parameters_p...&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// but never any qualification of any other type</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;volatile b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">static_assert</span>(a_tr&lt;const volatile b_t&lt;&gt;&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the &quot;template template indentity trait&quot; for a_t</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_template_p&gt;</div>
<div class="line"><span class="keyword">concept </span>a_tttr =</div>
<div class="line">    nkr::cpp::is_any_tttr&lt;template_template_p, a_t&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should constrain to a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tttr&lt;a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and any alias of a_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tttr&lt;alias_of_a_t&gt; == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// but never any other template</span></div>
<div class="line"><span class="keyword">static_assert</span>(a_tttr&lt;b_t&gt; == <span class="keyword">false</span>);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="_3199146d_6573_4ada_8636_0e3a2607116a"></a>
Interface Specialization Indirection</h1>
<p >(W.I.P)</p>
<p >Because we are using C++20 concepts, we have to work around a bug that exists in two of the major compilers. In order to use out-of-body class definitions, we take advantage of a pattern of concept partial specialization which indirectly maps onto separate types. An alias of this indirection is used as the primary type. The actual types that make up the specializations should be put in a non-colliding namespace one step interior to the namespace where the primary type lives. No members in the indirection template may be defined out-of-body.</p>
<p ><a href="https://github.com/r-neal-kelly/the_concept_bug">View a small but detailed example of this bug.</a></p>
<hr  />
<h1><a class="anchor" id="_839025a7_339e_4e65_a259_5feacb45ea12"></a>
Label Postfixes</h1>
<p >There are a number of postfixes on various labels throughout the library. They are helpful in avoiding name collisions, in particular with C++ keywords, but primarily they are used to differentiate between different kinds of entities, such as types, traits, and interfaces.</p>
<div class="fragment"><div class="line"><span class="comment">// &quot;_t&quot; is for &quot;type&quot;</span></div>
<div class="line"><span class="keyword">class </span>example_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_tr&quot; is for &quot;trait&quot;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>example_tr =</div>
<div class="line">    <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_i&quot; is for &quot;interface&quot;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">class </span>example_i</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
</div><!-- fragment --><p >You may have noticed that even the template parameter has a postifx, in particular <code>_p</code>. This allows for the easy definition of an alias with the same base name inside the template, a very frequent occurrence in <a class="el" href="namespacenkr.html">nkr</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// &quot;_p&quot; is for &quot;parameter&quot;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> parameter_p&gt;</div>
<div class="line"><span class="keyword">class </span>example_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> parameter_t   = parameter_p;</div>
<div class="line">};</div>
</div><!-- fragment --><p >Importantly, postfixes can indicate strong relationships between several entities. It is extremely frequent to find these related entities declared nearby each other in the same file. This repetition of the primary name in combination with the repetition of the extremely common postfixes allows for easy recall when working with these entities. For example we may have the following:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// a template type is frequently the primary entity in a relationship</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">class </span>entity_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// this &quot;tag&quot; can represent an instantiation of the primary entity</span></div>
<div class="line"><span class="keyword">struct </span>entity_tg    {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// whereas this &quot;template tag&quot; can represent the template itself</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt;</div>
<div class="line"><span class="keyword">struct </span>entity_ttg   {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// a &quot;trait&quot; can be used to constrain to an instantiated type</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">concept </span>entity_tr =</div>
<div class="line">    <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and a &quot;template trait&quot; to constrain to the template proper</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_p&gt;</div>
<div class="line"><span class="keyword">concept </span>entity_ttr =</div>
<div class="line">    <span class="keyword">true</span>;</div>
</div><!-- fragment --><p >You may have noticed that template types share the same postfix as a regular type: <code>_t</code>. This is because the meaning of the postfix remains the same with <code>_t</code> referring to an <code>instantiated type</code>, which is the most frequent occurrence of a template type label:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_t&quot; is not for &quot;template&quot;!</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">class </span>template_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_t&quot; is for &quot;type&quot;, as in &quot;instantiated type&quot;.</span></div>
<div class="line"><span class="keyword">using</span> instantiated_type_t = template_t&lt;int&gt;;</div>
</div><!-- fragment --><p >You may have also noticed the distinction between <code>_tg</code> and <code>_ttg</code> as well as <code>_tr</code> and <code>_ttr</code>. While <code>_tg</code> and <code>_tr</code> may be read as <code>tag</code> and <code>trait</code> and both reference a <code>type</code>, <code>_ttg</code> and <code>_ttr</code> may be read as <code>template tag</code> and <code>template trait</code>, both referencing a <code>template</code>. More formally, they may be read as <code>template of type tag</code> and <code>template of type trait</code>. This pattern extends indefinitely, and may be used to define a <code>template of template of type tag</code> and <code>template of template of type trait</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_tttg&quot; for &quot;template of template of type tag&quot;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_template_p&gt;</div>
<div class="line"><span class="keyword">struct  </span>entity_tttg {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_tttr&quot; for &quot;template of template of type trait&quot;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_template_p&gt;</div>
<div class="line"><span class="keyword">concept </span>entity_tttr =</div>
<div class="line">    <span class="keyword">true</span>;</div>
</div><!-- fragment --><p >nkr::tuple::templates_t is an example of this indefinite postfix pattern coming into play.</p>
<p >Postfixes even have a use in the naming of files, in particular header files. The most common postfixes come in a set of five, and like the various entities in the library proper, these postfixes are used to coordinate various files that have the same base name and imply a distinct relation to one another. These special postfixes used for file name are in addition to the postfix of the primary entity contained in the files:</p>
<div class="fragment"><div class="line"><span class="comment">// The non-postfix header pulls in everything but the &quot;_dox&quot; below. This is what you would normally use in your code.</span></div>
<div class="line"><span class="preprocessor">#include &quot;nkr/pointer/cpp_t.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_dec&quot; provides the declarations of entities contained in this header-group. The go-to file to know what is available.</span></div>
<div class="line"><span class="preprocessor">#include &quot;nkr/pointer/cpp_t_dec.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_dec_def&quot; defines the constexpr and other meta entities of &quot;_dec&quot;. A helpful technical distinction from &quot;_def&quot;.</span></div>
<div class="line"><span class="preprocessor">#include &quot;nkr/pointer/cpp_t_dec_def.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_def&quot; defines the non-constexpr and non-meta entities of &quot;_dec&quot;.</span></div>
<div class="line"><span class="preprocessor">#include &quot;nkr/pointer/cpp_t_def.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// &quot;_dox&quot; provides the doxygen comments used to create the documention for the entities of &quot;_dec&quot;.</span></div>
<div class="line"><span class="preprocessor">#include &quot;nkr/pointer/cpp_t_dox.h&quot;</span></div>
</div><!-- fragment --><p >The following is a comprehensive list of postfixes and their meanings as found throughout <a class="el" href="namespacenkr.html">nkr</a>:</p>
<h2><a class="anchor" id="_1382824d_0c2f_476c_b433_cf542fd6bdef"></a>
List of Label Postfixes</h2>
<ul>
<li><code>_dec</code> declarations</li>
<li><code>_dec_def</code> declaritive definitions</li>
<li><code>_def</code> definitions</li>
<li><code>_dox</code> documents or docs</li>
<li><code>_e</code> enumeration</li>
<li><code>_i</code> interface</li>
<li><code>_lb</code> label</li>
<li><code>_p</code> parameter</li>
<li><code>_t</code> type</li>
<li><code>_tg</code> tag</li>
<li><code>_tr</code> trait</li>
<li><code>_ttg</code> template tag</li>
<li><code>_ttr</code> template trait</li>
<li><code>_tttg</code> template template tag</li>
<li><code>_tttr</code> template template trait</li>
<li><code>_u</code> union</li>
</ul>
<hr  />
<h1><a class="anchor" id="_d720707b_2ea9_49b9_8625_8bca5b680359"></a>
Move Assignment of Volatile Instances</h1>
<p >(W.I.P)</p>
<p >In order to avoid an overload resolution ambiguity, we use a template operator to define the move assignment of volatile types. Because templates have a lower precedence than normal operators, this allows for both volatile and non-volatile instances as well as new constructions of the type to be move-assigned properly, and also allows other types that can be converted through a constructor of the type to be properly assigned as expected:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>example_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    example_t&amp;          operator =(<span class="keyword">const</span> example_t&amp; other);</div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp; operator =(<span class="keyword">const</span> example_t&amp; other) <span class="keyword">volatile</span>;</div>
<div class="line">    example_t&amp;          operator =(<span class="keyword">const</span> <span class="keyword">volatile</span> example_t&amp; other);</div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp; operator =(<span class="keyword">const</span> <span class="keyword">volatile</span> example_t&amp; other) <span class="keyword">volatile</span>;</div>
<div class="line">    example_t&amp;          operator =(example_t&amp;&amp; other);                                          <span class="comment">// may match any rvalue or temp value of example_t or anything implicitly convertible</span></div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp; operator =(example_t&amp;&amp; other) <span class="keyword">volatile</span>;                                 <span class="comment">// &quot;&quot;</span></div>
<div class="line">    example_t&amp;          operator =(tr&lt;just_volatile_tg, t&lt;example_t&gt;&gt; <span class="keyword">auto</span>&amp;&amp; other);            <span class="comment">// is only ever resolved to when given a volatile example_t&amp;&amp; and nothing else</span></div>
<div class="line">    <span class="keyword">volatile</span> example_t&amp; operator =(tr&lt;just_volatile_tg, t&lt;example_t&gt;&gt; <span class="keyword">auto</span>&amp;&amp; other) <span class="keyword">volatile</span>;   <span class="comment">// &quot;&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="_fb50a132_1997_4cb6_92b0_616254f27bae"></a>
One Hierarchy</h1>
<p >(W.I.P)</p>
<hr  />
<h1><a class="anchor" id="_ab449a60_e674_4d0a_91d9_557ec4c5660c"></a>
One Kind of Template Parameter</h1>
<p >A few key points need to be understood before expressing this principle:</p><ol type="1">
<li>Templates can take an large variety of entities as parameters including types, other templates, and literal values.</li>
<li>It is desirable to use templates as parameters in concepts.</li>
<li>Templates can have any number of parameters and so parameter packs must be used in the concept.</li>
<li>Parameter packs require one kind of template parameter and thus different entities cannot be mixed.</li>
</ol>
<p >With these points in mind, it only makes sense to restrict each individual template to accept only one kind of template argument, whatever that may be. Doing so allows us to statically constrain the use of templates in our functions, types, interfaces, and more. For example, <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> requires that every template used in an expression can only take types and nothing else.</p>
<hr  />
<h1><a class="anchor" id="_8f6a1988_bbdb_46ba_8746_40c02acda41c"></a>
Primary Inner Type</h1>
<p >Most every template type available in the library, regardless of how many parameters it has, contains a <code>primary inner type</code>. Usually, it's the first provided argument in the parameter list:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line"><span class="keyword">class </span>template_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> type_t    = type_p;   <span class="comment">// the primary inner type</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >Primary inner types are usually used for the sake of type constraints, particularly through use of an <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> expression with multiple operands:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// we can use any nkr template as long as it has a primary inner type</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">              template_t&lt;long&gt;,         <span class="comment">// we provide a primary inner type of &quot;long&quot;</span></div>
<div class="line">              any_tg, tt&lt;template_t&gt;,</div>
<div class="line">              of_any_tg, t&lt;long long&gt;   <span class="comment">// but we&#39;re looking for &quot;long long&quot;, so it&#39;s false</span></div>
<div class="line">&gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">              template_t&lt;long long&gt;,    <span class="comment">// we change it to &quot;long long&quot; to get true</span></div>
<div class="line">              any_tg, tt&lt;template_t&gt;,</div>
<div class="line">              of_any_tg, t&lt;long long&gt;</div>
<div class="line">&gt; == <span class="keyword">true</span>);</div>
</div><!-- fragment --><p >It should be noted that each template does not need to have the same alias name for the <code>primary inner type</code>, nor does it need to reuse the parameter name in the name of its alias:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line"><span class="keyword">class </span>template_t</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> value_t   = type_p;   <span class="comment">// does not use the parameter&#39;s name</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >So in order to know what the <code>primary inner type</code> is for a particular template instantiation, we need to use nkr::interface::type_i:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line"><span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// here we give our example template a primary inner type of &quot;int&quot;</span></div>
<div class="line"><span class="keyword">using</span> type_t = template_t&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> interface_of_type_t = nkr::interface::type_i&lt;type_t&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// we can access the primary inner type with an alias contained in the interface</span></div>
<div class="line"><span class="keyword">using</span> primary_inner_type_of_type_t = interface_of_type_t::of_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// it should be equal to what we gave our template_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;primary_inner_type_of_type_t, int&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> interface_of_interface_of_type_t = nkr::interface::type_i&lt;interface_of_type_t&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// coincidentally, the interface itself has a primary inner type equal to type_t</span></div>
<div class="line"><span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;interface_of_interface_of_type_t::of_t, type_t&gt;);</div>
</div><!-- fragment --><p >Common alias names for a <code>primary inner type</code> are <code>type_t</code>, <code>value_t</code>, and <code>unit_t</code>.</p>
<hr  />
<h1><a class="anchor" id="_94c723c3_0213_4866_a383_50edc6ef02bd"></a>
Primary Inner Value</h1>
<p >(W.I.P)</p>
<hr  />
<h1><a class="anchor" id="_a742d628_4b70_448e_bdc4_594f6954bdb2"></a>
Qualification Support</h1>
<p >(W.I.P)</p>
<p >This library provides methods available for <code>non-qualified</code>, <code>const</code>, <code>volatile</code>, and <code>const volatile</code> qualifications of as many types as possible. Exceptions only occur when it doesn't make sense for a particular type to have a certain qualification, or for the aliased C++ types that do not define all qualifications.</p>
<hr  />
<h1><a class="anchor" id="_5451462d_8ed6_4fc2_86f0_b2f98e5efdc6"></a>
Type Documentation</h1>
<p >(W.I.P)</p>
<hr  />
<h1><a class="anchor" id="_5a685522_8b24_41da_83f3_03603bf8965c"></a>
Type Sections</h1>
<p >(W.I.P) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
