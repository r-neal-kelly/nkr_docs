<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Designs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language, an extensible string, and more, all developed alongside a comprehensive test suite.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Designs </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="_8f6a1988_bbdb_46ba_8746_40c02acda41c"></a>
Primary Inner Type</h1>
<p >Most every template type available in the library, regardless of how many parameters it has, contains a <code>primary inner type</code>. Usually, it's the first provided argument in the parameter list:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line">    <span class="keyword">class </span>template_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> type_t    = type_p;   <span class="comment">// the primary inner type</span></div>
<div class="line">    };</div>
<div class="ttc" id="anamespacenkr_html"><div class="ttname"><a href="namespacenkr.html">nkr</a></div><div class="ttdoc">The entire library is contained within this namespace.</div><div class="ttdef"><b>Definition:</b> array/cpp_t_dec.h:14</div></div>
</div><!-- fragment --><p >Primary inner types are usually used for the sake of type constraints, particularly through use of an <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> expression with multiple operands:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can use any nkr template as long as it has a primary inner type</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">                  template_t&lt;long&gt;,         <span class="comment">// we provide a primary inner type of &quot;long&quot;</span></div>
<div class="line">                  any_tg, tt&lt;template_t&gt;,</div>
<div class="line">                  of_any_tg, t&lt;long long&gt;   <span class="comment">// but we&#39;re looking for &quot;long long&quot;, so it&#39;s false</span></div>
<div class="line">    &gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">                  template_t&lt;long long&gt;,    <span class="comment">// we change it to &quot;long long&quot; to get true</span></div>
<div class="line">                  any_tg, tt&lt;template_t&gt;,</div>
<div class="line">                  of_any_tg, t&lt;long long&gt;</div>
<div class="line">    &gt; == <span class="keyword">true</span>);</div>
</div><!-- fragment --><p >It should be noted that each template does not need to have the same alias name for the <code>primary inner type</code>, nor does it need to reuse the parameter name in the name of its alias:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line">    <span class="keyword">class </span>template_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> value_t   = type_p;   <span class="comment">// does not use the parameter&#39;s name</span></div>
<div class="line">    };</div>
</div><!-- fragment --><p >So in order to know what the <code>primary inner type</code> is for a particular template instantiation, we need to use nkr::interface::type_i:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// here we give our example template a primary inner type of &quot;int&quot;</span></div>
<div class="line">    <span class="keyword">using</span> type_t = template_t&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> interface_of_type_t = nkr::interface::type_i&lt;type_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can access the primary inner type with an alias contained in the interface</span></div>
<div class="line">    <span class="keyword">using</span> primary_inner_type_of_type_t = interface_of_type_t::of_t;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// it should be equal to what we gave our template_t</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;primary_inner_type_of_type_t, int&gt;);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> interface_of_interface_of_type_t = nkr::interface::type_i&lt;interface_of_type_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// coincidentally, the interface itself has a primary inner type equal to type_t</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;interface_of_interface_of_type_t::of_t, type_t&gt;);</div>
</div><!-- fragment --><p >Common alias names for a <code>primary inner type</code> are <code>type_t</code>, <code>value_t</code>, and <code>unit_t</code>.</p>
<hr  />
<h1><a class="anchor" id="_ab449a60_e674_4d0a_91d9_557ec4c5660c"></a>
The "One Kind of Template Parameter" Principle</h1>
<p >A few key points need to be understood before expressing this principle:</p><ol type="1">
<li>Templates can take an large variety of entities as parameters including types, other templates, and literal values.</li>
<li>It is desirable to use templates as parameters in concepts.</li>
<li>Templates can have any number of parameters and so parameter packs must be used in the concept.</li>
<li>Parameter packs require one kind of template parameter and thus different entities cannot be mixed.</li>
</ol>
<p >With these points in mind, it only makes sense to restrict each individual template to accept only one kind of template argument, whatever that may be. Doing so allows us to statically constrain the use of templates in our functions, types, interfaces, and more. For example, <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> requires that every template used in an expression can only take types and nothing else.</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
