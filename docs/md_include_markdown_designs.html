<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nkr: Designs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nkr
   </div>
   <div id="projectbrief">A C++20 library with a custom meta-programming language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Designs </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This page contains many key concepts revolving around design decisions that have been made with <a class="el" href="namespacenkr.html">nkr</a>. Each section thoroughly explains why these designs exist and how best to take advantage of them.</p>
<ul>
<li><a class="el" href="md_include_markdown_designs.html#_1f10466e_b496_498a_a930_6c7227b37371">Global Equality Operators</a></li>
<li><a class="el" href="md_include_markdown_designs.html#_839025a7_339e_4e65_a259_5feacb45ea12">Label Postfixes</a><ul>
<li><a class="el" href="md_include_markdown_designs.html#_1382824d_0c2f_476c_b433_cf542fd6bdef">List of Label Postfixes</a></li>
</ul>
</li>
<li><a class="el" href="md_include_markdown_designs.html#_8f6a1988_bbdb_46ba_8746_40c02acda41c">Primary Inner Type</a></li>
<li><a class="el" href="md_include_markdown_designs.html#_ab449a60_e674_4d0a_91d9_557ec4c5660c">One Kind of Template Parameter</a></li>
</ul>
<hr  />
<h1><a class="anchor" id="_1f10466e_b496_498a_a930_6c7227b37371"></a>
Global Equality Operators</h1>
<p >We define equality operators outside of the <a class="el" href="namespacenkr.html">nkr</a> namespace and in the global scope. We follow a <b>very specific pattern</b>. For <code>constexpr</code> types we write:</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">class </span>constexpr_t;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t   operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="ttc" id="aconceptnkr_1_1tr_html"><div class="ttname"><a href="conceptnkr_1_1tr.html">nkr::tr</a></div><div class="ttdoc">Used to filter a type by its qualifications, and by other types, templates, identities,...</div><div class="ttdef"><b>Definition:</b> tr_dec.h:261</div></div>
<div class="ttc" id="anamespacenkr_html"><div class="ttname"><a href="namespacenkr.html">nkr</a></div><div class="ttdoc">The entire library is contained within this namespace.</div><div class="ttdef"><b>Definition:</b> array/cpp_t_dec.h:14</div></div>
<div class="ttc" id="anamespacenkr_html_aecb8f05af8f5d93778ce60239336d8e3"><div class="ttname"><a href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t</a></div><div class="ttdeci">nkr::tr$::ts&lt; AND_tg, nkr::tuple::types_t&lt; type_p &gt; &gt; t</div><div class="ttdoc">A way to wrap a single type for use with an nkr::TR expression, to differentiate it from a template.</div><div class="ttdef"><b>Definition:</b> tr_dec.h:175</div></div>
</div><!-- fragment --><p >And for non-<code>constexpr</code> constructible types we merely drop the <code>constexpr</code> at the beginning of the declaration:</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">class </span>non_constexpr_t;</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::non_constexpr_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
</div><!-- fragment --><p >Following the above pattern makes all equality operator overloads <b>templates</b>, and with that point in mind, this pattern avoids two very important conflicts:</p><ol type="1">
<li>Because the first template parameter, and <em>only</em> the first template parameter is constrained specifically to an <code>identity</code> and never a <code>generic</code>, <b>this pattern can <em>never</em> have ambiguous operator overload collisions with other operators that follow the same exact pattern</b>. This allows us to extend this pattern to all types ad infinitum, including types that inherit base types with their own overloads defined or types that can otherwise implicitly be converted to another.</li>
<li>Because all possible values are covered in the second parameter, including both lvalues and rvalues of any type whatsoever, <b>it is <em>impossible</em> for operator overload resolution to resolve to any implicit conversions from the second type</b>, in particular during reverse operator resolution - a potentially frustrating addition to the C++20 standard.</li>
</ol>
<p >Following this pattern gives an extreme amount of flexibility for users. A user need not worry about the order of their arguments and whether including this or that file will somehow cause the compiler to spit out a thousand-line-long error message, resulting in a headache for the user every time it happens.</p>
<p >However, this comes at the cost of extra development effort. Every single type must define their own operator overloads explicitly. This means if you wish to use the overload of another type, you must define its operators and explicitly cast to that type. For this reason, the pattern was designed such that you only need to define one of the eight operators, and the rest can be easily defined as proxies.</p>
<p >The following is a full example of how one would define the operators for two different types, neither of which knows if the other is compatible. Both of them have an identifiable <a class="el" href="md_include_markdown_designs.html#_8f6a1988_bbdb_46ba_8746_40c02acda41c">primary inner type</a>, which adds options to their algorithms that otherwise might not be there:</p>
<div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a> {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">class </span>equality_a_t</div>
<div class="line">        {</div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="comment">// The primary inner type.</span></div>
<div class="line">            <span class="keyword">using</span> value_t   = long;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            value_t value;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="keyword">constexpr</span> equality_a_t(value_t value) noexcept :</div>
<div class="line">                value(value)</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">class </span>equality_b_t</div>
<div class="line">        {</div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="comment">// The primary inner type. It&#39;s different from equality_a_t&#39;s.</span></div>
<div class="line">            <span class="keyword">using</span> value_t   = <span class="keywordtype">long</span> long;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            value_t value;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="keyword">constexpr</span> equality_b_t(value_t value) noexcept :</div>
<div class="line">                value(value)</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Notice that we can construct this type with equality_a_t.</span></div>
<div class="line">            <span class="keyword">constexpr</span> equality_b_t(equality_a_t value) noexcept :</div>
<div class="line">                value(value.value)</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Forward declare equality_a_t&#39;s ops so it can see equality_b_t&#39;s ops.</span></div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// And vice versa.</span></div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> nkr::boolean::cpp_t operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Here we define equality_a_t&#39;s operators.</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We want the value_t and not a value_t&amp; type.</span></div>
<div class="line">        <span class="keyword">using</span> a_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(a)&gt;;</div>
<div class="line">        <span class="keyword">using</span> b_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(b)&gt;;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::is_any_tr&lt;b_t, a_t&gt;) {</div>
<div class="line">            <span class="comment">// If b_t is equality_a_t, it&#39;s super easy to compare the two.</span></div>
<div class="line">            <span class="keywordflow">return</span> a.value == b.value;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;&gt;) {</div>
<div class="line">            <span class="comment">// If b_t is equality_b_t, then this won&#39;t be branched to because it doesn&#39;t have a cast to</span></div>
<div class="line">            <span class="comment">// value_t operator. However another type might, and because our type defines equality based on</span></div>
<div class="line">            <span class="comment">// its primary inner type, it makes sense to have this branch. However if our type doesn&#39;t have</span></div>
<div class="line">            <span class="comment">// a primary inner type, it maybe should be excluded. This technique relies on a good design of</span></div>
<div class="line">            <span class="comment">// b_t, which should be castable to other types only when it&#39;s meaningful.</span></div>
<div class="line">            <span class="keywordflow">return</span> a.value == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;a_t&gt;&gt;) {</div>
<div class="line">            <span class="comment">// If b_t is equality_b_t, then this won&#39;t be branched to because a_t cannot be constructed from</span></div>
<div class="line">            <span class="comment">// an equality_b_t, nor can equality_b_t be cast to a_t. Notice that this recursively calls this</span></div>
<div class="line">            <span class="comment">// operator, we don&#39;t need to define a_t == a_t twice!</span></div>
<div class="line">            <span class="keywordflow">return</span> a == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;a_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;a_t, nkr::cpp::just_non_qualified_t&lt;b_t&gt;&gt;) {</div>
<div class="line">            <span class="comment">// If b_t is equality_b_t, then even though equality_a_t cannot be cast to equality_b_t,</span></div>
<div class="line">            <span class="comment">// equality_b_t can be constructed with equality_a_t, so this is the branch that will compile.</span></div>
<div class="line">            <span class="comment">// However take note that equality_b_t&#39;s operators must be defined!</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;b_t&gt;<span class="keyword">&gt;</span>(a) == b;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Bail, because there&#39;s no defined way to compare these two types. Make sure to let the user</span></div>
<div class="line">            <span class="comment">// know what happend. As complicated as it is, this standards compliant technique works great:</span></div>
<div class="line">            [] &lt;nkr::boolean::cpp_t _ = <span class="keyword">false</span>&gt;() { <span class="keyword">static_assert</span>(_, <span class="stringliteral">&quot;these two values can not be compared.&quot;</span>); }();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The rest of these just call the above operator.</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_a_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Here we do the same thing as above, but for equality_b_t.</span></div>
<div class="line">    <span class="comment">// We have the same algorithm because the two types are similar, but other types may have different algorithms.</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> a_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(a)&gt;;</div>
<div class="line">        <span class="keyword">using</span> b_t = nkr::cpp::reference_value_t&lt;<span class="keyword">decltype</span>(b)&gt;;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::is_any_tr&lt;b_t, a_t&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> a.value == b.value;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> a.value == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;typename a_t::value_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;b_t, nkr::cpp::just_non_qualified_t&lt;a_t&gt;&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> a == <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;a_t&gt;<span class="keyword">&gt;</span>(b);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (nkr::cpp::to_tr&lt;a_t, nkr::cpp::just_non_qualified_t&lt;b_t&gt;&gt;) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>nkr::cpp::just_non_qualified_t&lt;b_t&gt;<span class="keyword">&gt;</span>(a) == b;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            [] &lt;nkr::boolean::cpp_t _ = <span class="keyword">false</span>&gt;() { <span class="keyword">static_assert</span>(_, <span class="stringliteral">&quot;these two values can not be compared.&quot;</span>); }();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator ==(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> nkr::boolean::cpp_t</div>
<div class="line">        operator !=(<span class="keyword">const</span> <a class="code hl_concept" href="conceptnkr_1_1tr.html">nkr::tr</a>&lt;nkr::any_tg, <a class="code hl_typedef" href="namespacenkr.html#aecb8f05af8f5d93778ce60239336d8e3">nkr::t&lt;nkr::equality_b_t&gt;</a>&gt; <span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; b)</div>
<div class="line">        <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> !operator ==(a, b);</div>
<div class="line">    }</div>
</div><!-- fragment --><p >Now we can fully equate values of these two types in every imaginable way:</p>
<div class="fragment"><div class="line">    <span class="comment">// This calls equality_a_t branch 1</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::equality_a_t(1) == nkr::equality_a_t(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This calls equality_a_t branch 3 then equality_b_t branch 1</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::equality_a_t(1) == nkr::equality_b_t(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This calls equality_b_t branch 1</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::equality_b_t(1) == nkr::equality_b_t(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This calls equality_b_t branch 3 then equality_b_t branch 1</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::equality_b_t(1) == nkr::equality_a_t(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Even const and/or volatile values play nicely:</span></div>
<div class="line">    <span class="keyword">const</span> nkr::equality_a_t equality_a = 1;</div>
<div class="line">    <span class="keyword">volatile</span> nkr::equality_a_t equality_b = 1;</div>
<div class="line"> </div>
<div class="line">    CHECK((equality_a == equality_b));</div>
<div class="line">    CHECK((equality_b == equality_a));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Any combination of lvalues, rvalues, and temp values will just work:</span></div>
<div class="line">    CHECK((nkr::equality_a_t(1) == equality_b));</div>
<div class="line">    CHECK((equality_a == nkr::cpp::Move(equality_b)));</div>
<div class="line"> </div>
<div class="line">    CHECK((nkr::equality_b_t(1) == equality_a));</div>
<div class="line">    CHECK((nkr::cpp::Move(equality_b) == nkr::equality_a_t(1)));</div>
</div><!-- fragment --><p >Because all of these operators are templates, even for non-<code>constexpr</code> subjects, <code>if constexpr</code> expressions can and should be used to define the algorithms. This allows the compiler to completely optimize away most if not all the function calls that result when equating values of these and other types that have these operators.</p>
<hr  />
<h1><a class="anchor" id="_839025a7_339e_4e65_a259_5feacb45ea12"></a>
Label Postfixes</h1>
<p >There are a number of postfixes on various labels throughout the library. They are helpful in avoiding name collisions, in particular with C++ keywords, but primarily they are used to differentiate between different kinds of entities, such as types, traits, and interfaces.</p>
<div class="fragment"><div class="line">    <span class="comment">// &quot;_t&quot; is for &quot;type&quot;</span></div>
<div class="line">    <span class="keyword">class </span>example_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_tr&quot; is for &quot;trait&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">concept </span>example_tr =</div>
<div class="line">        <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_i&quot; is for &quot;interface&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">class </span>example_i</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
</div><!-- fragment --><p >You may have noticed that even the template parameter has a postifx, in particular <code>_p</code>. This allows for the easy definition of an alias with the same base name inside the template, a very frequent occurrence in nkr:</p>
<div class="fragment"><div class="line">    <span class="comment">// &quot;_p&quot; is for &quot;parameter&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> parameter_p&gt;</div>
<div class="line">    <span class="keyword">class </span>example_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> parameter_t   = parameter_p;</div>
<div class="line">    };</div>
</div><!-- fragment --><p >Importantly, postfixes can indicate strong relationships between several entities. It is extremely frequent to find these related entities declared nearby each other in the same file. This repetition of the primary name in combination with the repetition of the extremely common postfixes allows for easy recall when working with these entities. For example we may have the following:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a template type is frequently the primary entity in a relationship</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">class </span>entity_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this &quot;tag&quot; can represent an instantiation of the primary entity</span></div>
<div class="line">    <span class="keyword">struct </span>entity_tg    {};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// whereas this &quot;template tag&quot; can represent the template itself</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</div>
<div class="line">    <span class="keyword">struct </span>entity_ttg   {};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a &quot;trait&quot; can be used to constrain to an instantiated type</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">concept </span>entity_tr =</div>
<div class="line">        <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// and a &quot;template trait&quot; to constrain to the template proper</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_p&gt;</div>
<div class="line">    <span class="keyword">concept </span>entity_ttr =</div>
<div class="line">        <span class="keyword">true</span>;</div>
</div><!-- fragment --><p >You may have noticed that template types share the same postfix as a regular type: <code>_t</code>. This is because the meaning of the postfix remains the same with <code>_t</code> referring to an <code>instantiated type</code>, which is the most frequent occurrence of a template type label:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_t&quot; is not for &quot;template&quot;!</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">class </span>template_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_t&quot; is for &quot;type&quot;, as in &quot;instantiated type&quot;.</span></div>
<div class="line">    <span class="keyword">using</span> instantiated_type_t = template_t&lt;int&gt;;</div>
</div><!-- fragment --><p >You may have also noticed the distinction between <code>_tg</code> and <code>_ttg</code> as well as <code>_tr</code> and <code>_ttr</code>. While <code>_tg</code> and <code>_tr</code> may be read as <code>tag</code> and <code>trait</code> and both reference a <code>type</code>, <code>_ttg</code> and <code>_ttr</code> may be read as <code>template tag</code> and <code>template trait</code>, both referencing a <code>template</code>. More formally, they may be read as <code>template of type tag</code> and <code>template of type trait</code>. This pattern extends indefinitely, and may be used to define a <code>template of template of type tag</code> and <code>template of template of type trait</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_tttg&quot; for &quot;template of template of type tag&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_template_p&gt;</div>
<div class="line">    <span class="keyword">struct  </span>entity_tttg {};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_tttr&quot; for &quot;template of template of type trait&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> ...&gt; <span class="keyword">typename</span> template_template_p&gt;</div>
<div class="line">    <span class="keyword">concept </span>entity_tttr =</div>
<div class="line">        <span class="keyword">true</span>;</div>
</div><!-- fragment --><p >nkr::tuple::templates_t is an example of this indefinite postfix pattern coming into play.</p>
<p >Postfixes even have a use in the naming of files, in particular header files. The most common postfixes come in a set of five, and like the various entities in the library proper, these postfixes are use to coordinate various files that have the same base name and imply a distinct relation to one another. They are in addition to the postfix of the primary entity contained in the files:</p>
<div class="fragment"><div class="line">    <span class="comment">// The non-postfix header pulls in everything but the &quot;_dox&quot; below. This is what you would normally use in your code.</span></div>
<div class="line"><span class="preprocessor">    #include &quot;nkr/pointer/cpp_t.h&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_dec&quot; provides the declarations of entities contained in this header-group. The go-to file to know what is available.</span></div>
<div class="line"><span class="preprocessor">    #include &quot;nkr/pointer/cpp_t_dec.h&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_dec_def&quot; defines the constexpr and other meta entities of &quot;_dec&quot;. A helpful technical distinction from &quot;_def&quot;.</span></div>
<div class="line"><span class="preprocessor">    #include &quot;nkr/pointer/cpp_t_dec_def.h&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_def&quot; defines the non-constexpr and non-meta entities of &quot;_dec&quot;.</span></div>
<div class="line"><span class="preprocessor">    #include &quot;nkr/pointer/cpp_t_def.h&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;_dox&quot; provides the doxygen comments used to create the documention for the entities of &quot;_dec&quot;.</span></div>
<div class="line"><span class="preprocessor">    #include &quot;nkr/pointer/cpp_t_dox.h&quot;</span></div>
</div><!-- fragment --><p >The following is a comprehensive list of postfixes and their meanings as found throughout nkr:</p>
<h2><a class="anchor" id="_1382824d_0c2f_476c_b433_cf542fd6bdef"></a>
List of Label Postfixes</h2>
<ul>
<li><code>_dec</code> declarations</li>
<li><code>_dec_def</code> declaration definitions</li>
<li><code>_def</code> definitions</li>
<li><code>_dox</code> documents or docs</li>
<li><code>_i</code> interface</li>
<li><code>_lb</code> label</li>
<li><code>_p</code> parameter</li>
<li><code>_t</code> type</li>
<li><code>_tg</code> tag</li>
<li><code>_tr</code> trait</li>
<li><code>_ttg</code> template tag</li>
<li><code>_ttr</code> template trait</li>
<li><code>_tttg</code> template template tag</li>
<li><code>_tttr</code> template template trait</li>
<li><code>_u</code> union</li>
</ul>
<hr  />
<h1><a class="anchor" id="_8f6a1988_bbdb_46ba_8746_40c02acda41c"></a>
Primary Inner Type</h1>
<p >Most every template type available in the library, regardless of how many parameters it has, contains a <code>primary inner type</code>. Usually, it's the first provided argument in the parameter list:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line">    <span class="keyword">class </span>template_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> type_t    = type_p;   <span class="comment">// the primary inner type</span></div>
<div class="line">    };</div>
</div><!-- fragment --><p >Primary inner types are usually used for the sake of type constraints, particularly through use of an <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> expression with multiple operands:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can use any nkr template as long as it has a primary inner type</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">                  template_t&lt;long&gt;,         <span class="comment">// we provide a primary inner type of &quot;long&quot;</span></div>
<div class="line">                  any_tg, tt&lt;template_t&gt;,</div>
<div class="line">                  of_any_tg, t&lt;long long&gt;   <span class="comment">// but we&#39;re looking for &quot;long long&quot;, so it&#39;s false</span></div>
<div class="line">    &gt; == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(tr&lt;</div>
<div class="line">                  template_t&lt;long long&gt;,    <span class="comment">// we change it to &quot;long long&quot; to get true</span></div>
<div class="line">                  any_tg, tt&lt;template_t&gt;,</div>
<div class="line">                  of_any_tg, t&lt;long long&gt;</div>
<div class="line">    &gt; == <span class="keyword">true</span>);</div>
</div><!-- fragment --><p >It should be noted that each template does not need to have the same alias name for the <code>primary inner type</code>, nor does it need to reuse the parameter name in the name of its alias:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p, <span class="keyword">typename</span> ...maybe_more_types_p&gt;</div>
<div class="line">    <span class="keyword">class </span>template_t</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using</span> value_t   = type_p;   <span class="comment">// does not use the parameter&#39;s name</span></div>
<div class="line">    };</div>
</div><!-- fragment --><p >So in order to know what the <code>primary inner type</code> is for a particular template instantiation, we need to use nkr::interface::type_i:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacenkr.html">nkr</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_p&gt;</div>
<div class="line">    <span class="keyword">using</span> template_t = nkr::pointer::cpp_t&lt;type_p&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// here we give our example template a primary inner type of &quot;int&quot;</span></div>
<div class="line">    <span class="keyword">using</span> type_t = template_t&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> interface_of_type_t = nkr::interface::type_i&lt;type_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can access the primary inner type with an alias contained in the interface</span></div>
<div class="line">    <span class="keyword">using</span> primary_inner_type_of_type_t = interface_of_type_t::of_t;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// it should be equal to what we gave our template_t</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;primary_inner_type_of_type_t, int&gt;);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> interface_of_interface_of_type_t = nkr::interface::type_i&lt;interface_of_type_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// coincidentally, the interface itself has a primary inner type equal to type_t</span></div>
<div class="line">    <span class="keyword">static_assert</span>(nkr::cpp::is_tr&lt;interface_of_interface_of_type_t::of_t, type_t&gt;);</div>
</div><!-- fragment --><p >Common alias names for a <code>primary inner type</code> are <code>type_t</code>, <code>value_t</code>, and <code>unit_t</code>.</p>
<hr  />
<h1><a class="anchor" id="_ab449a60_e674_4d0a_91d9_557ec4c5660c"></a>
One Kind of Template Parameter</h1>
<p >A few key points need to be understood before expressing this principle:</p><ol type="1">
<li>Templates can take an large variety of entities as parameters including types, other templates, and literal values.</li>
<li>It is desirable to use templates as parameters in concepts.</li>
<li>Templates can have any number of parameters and so parameter packs must be used in the concept.</li>
<li>Parameter packs require one kind of template parameter and thus different entities cannot be mixed.</li>
</ol>
<p >With these points in mind, it only makes sense to restrict each individual template to accept only one kind of template argument, whatever that may be. Doing so allows us to statically constrain the use of templates in our functions, types, interfaces, and more. For example, <a class="el" href="conceptnkr_1_1tr.html" title="Used to filter a type by its qualifications, and by other types, templates, identities,...">nkr::tr</a> requires that every template used in an expression can only take types and nothing else. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
